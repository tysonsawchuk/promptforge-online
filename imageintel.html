<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PF — Mapper Wizard Lab (Fixed Image Load)</title>
<meta name="description" content="On-device multi-face mapper with step-by-step wizard. Fixed image loading and persistent canvas render."/>
<meta name="robots" content="noindex,nofollow"/>
<style>
:root{
  --bg:#0b0f14; --ink:#d6f5ff; --edge:#232a33; --aqua:#64f2e3; --ok:#55d69a; --bad:#ff6b6b; --dim:#9db1bd;
}
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:ui-monospace, Menlo, Consolas, monospace;}
.wrap{max-width:1180px;margin:0 auto;padding:16px}
h1{margin:0 0 10px;font-size:1.1rem}
.badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0b1117dd}
.ok{color:var(--ok)} .bad{color:var(--bad)} .note{color:var(--dim)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
.btn{cursor:pointer;border:1.5px solid var(--aqua);background:#131922;color:#b8fff6;padding:8px 12px;border-radius:10px;font-weight:700}
.btn:hover{background:var(--aqua);color:#0e131a;border-color:#fff}
.btn:disabled{opacity:.5;cursor:not-allowed}
.stepper{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:12px 0}
.step{border:1px solid var(--edge);border-radius:10px;padding:10px;background:#0f161f}
.step.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.stage{position:relative;border:1px solid var(--edge);border-radius:12px;background:#0d131a;overflow:hidden}
.inner{position:relative;aspect-ratio:16/9}
canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
.legend{position:absolute;left:12px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
.tab-head{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
.tab-head button{cursor:pointer;border:1px solid var(--edge);background:#0e141a;color:var(--ink);padding:8px 12px;border-radius:9px}
.tab-head button.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.tab{display:none;margin-top:10px;border:1px solid var(--edge);border-radius:12px;padding:12px;background:#0e141a}
.tab.active{display:block}
textarea.out{width:100%;min-height:120px;background:#0b1117;color:#d8faff;border:1px solid #1b242e;border-radius:8px;padding:10px}
.toastbox{position:fixed;right:14px;bottom:14px;display:flex;flex-direction:column;gap:10px;z-index:5000}
.toast{background:#121823ee;border:1px solid var(--edge);color:#defaff;padding:10px 12px;border-radius:10px;min-width:220px;box-shadow:0 4px 18px #0006}
</style>
</head>
<body>
<div class="wrap">
  <h1>Mapper Wizard Lab (Image Load Fix)</h1>

  <div class="row">
    <span class="badge">Status: <b id="statusText">booting…</b></span>
    <span class="badge">Bundle: <b id="bundleState">…</b></span>
    <span class="badge">Model: <b id="modelState">…</b></span>
  </div>

  <div class="stage">
    <div class="inner" id="stage">
      <canvas id="prev"></canvas>
      <canvas id="over"></canvas>
      <div class="legend">
        <span class="badge">faces: <span id="faceCount">0</span></span>
        <span class="badge">active face: <span id="activeFaceIdx">—</span></span>
      </div>
    </div>
  </div>

  <div class="stepper">
    <div class="step active" id="s1">
      <h3>Step 1 — Load</h3>
      <div class="row">
        <input id="file" type="file" accept="image/*"/>
        <button class="btn" id="demo">Load Demo</button>
        <button class="btn" id="goTo2" disabled>Next</button>
      </div>
      <div class="note">Pick any image. It will draw immediately to the canvas and stay visible.</div>
    </div>

    <div class="step" id="s2">
      <h3>Step 2 — Options</h3>
      <div class="row">
        <label><input type="checkbox" id="scanFace" checked> Face</label>
        <label><input type="checkbox" id="scanBody"> Body</label>
        <label><input type="checkbox" id="scanNSFW"> NSFW</label>
      </div>
      <div class="row">
        <button class="btn" id="preview">Preview Overlay</button>
        <button class="btn" id="goTo3">Next</button>
      </div>
    </div>

    <div class="step" id="s3">
      <h3>Step 3 — Cloud (optional)</h3>
      <div class="row">
        <label><input type="checkbox" id="useCloud"> Use HuggingFace</label>
        <input id="hfToken" placeholder="hf_... token" style="min-width:320px;border:1px solid var(--edge);background:#0f141a;color:#fff;padding:6px 10px;border-radius:8px">
        <button class="btn" id="goTo4">Run Analysis</button>
      </div>
      <div class="note">BLIP caption, CLIP interrogator, DETR objects (if enabled).</div>
    </div>

    <div class="step" id="s4">
      <h3>Step 4 — Results</h3>
      <div class="row" id="faceSelector"></div>
      <div class="row">
        <button class="btn" id="copySFW" disabled>Copy SFW</button>
        <button class="btn" id="copyNSFW" disabled>Copy NSFW</button>
        <button class="btn" id="exportJSON" disabled>Export JSON</button>
        <button class="btn" id="rerun">Re-Run</button>
      </div>
    </div>
  </div>

  <div class="tab-head">
    <button class="active" data-tab="sfw">SFW Prompt</button>
    <button data-tab="nsfw">NSFW Prompt</button>
    <button data-tab="meas">Measurements</button>
    <button data-tab="json">JSON</button>
    <button data-tab="diag">Diagnostics</button>
  </div>
  <div id="tab_sfw" class="tab active"><textarea id="outSFW" class="out" readonly></textarea></div>
  <div id="tab_nsfw" class="tab"><textarea id="outNSFW" class="out" readonly></textarea></div>
  <div id="tab_meas" class="tab"><textarea id="outMeas" class="out" readonly></textarea></div>
  <div id="tab_json" class="tab"><textarea id="outJson" class="out" readonly></textarea></div>
  <div id="tab_diag" class="tab"><div class="note">UA: <span id="ua"></span></div></div>
</div>

<div class="toastbox" id="toastbox"></div>

<script type="module">
/* ========= Hard requirements fix: KEEP IMAGE VISIBLE & DRAW IMMEDIATELY ========= */

const toastbox=document.getElementById('toastbox');
const toast=(msg)=>{const d=document.createElement('div');d.className='toast';d.textContent=msg;toastbox.appendChild(d);setTimeout(()=>d.remove(),2600);};

const cPrev=document.getElementById('prev');
const cOver=document.getElementById('over');
const ctxPrev=cPrev.getContext('2d',{willReadFrequently:true});
const ctxOver=cOver.getContext('2d');

const stage=document.getElementById('stage');
function sizeCanvases(){
  const r=stage.getBoundingClientRect();
  // *** Simple, robust: logical pixels == CSS pixels ***
  cPrev.width = cOver.width = Math.max(1, Math.round(r.width));
  cPrev.height= cOver.height= Math.max(1, Math.round(r.height));
  cPrev.style.width=cOver.style.width=r.width+'px';
  cPrev.style.height=cOver.style.height=r.height+'px';
  // On resize, re-draw the current image if any:
  if(currentImage) drawImageLetterbox(currentImage);
}
window.addEventListener('resize', sizeCanvases, {passive:true}); sizeCanvases();

let currentImage=null;  // HTMLImageElement currently loaded
let imgFit=null;        // {dx,dy,dw,dh,W,H}

/** Draws img onto cPrev with letterbox and updates imgFit */
function drawImageLetterbox(img){
  const W=cPrev.width, H=cPrev.height;
  ctxPrev.clearRect(0,0,W,H);
  if(!img?.naturalWidth || !img?.naturalHeight){ return; }
  const r=Math.min(W/img.naturalWidth, H/img.naturalHeight);
  const dw=Math.max(1, Math.round(img.naturalWidth*r));
  const dh=Math.max(1, Math.round(img.naturalHeight*r));
  const dx=Math.round((W-dw)/2);
  const dy=Math.round((H-dh)/2);
  ctxPrev.imageSmoothingEnabled=true;
  ctxPrev.imageSmoothingQuality='high';
  ctxPrev.drawImage(img, dx,dy,dw,dh);
  imgFit={W,H,dx,dy,dw,dh};
}

/* ========= Loader (ESM, one CDN for stability) ========= */
document.getElementById('ua').textContent=navigator.userAgent;
const bundleState=document.getElementById('bundleState');
const modelState=document.getElementById('modelState');
const statusText=document.getElementById('statusText');

let FilesetResolver, FaceLandmarker, PoseLandmarker, DrawingUtils;
let face=null, pose=null;

(async ()=>{
 try{
   const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs");
   ({FilesetResolver, FaceLandmarker, PoseLandmarker, DrawingUtils} = vision);
   bundleState.innerHTML='<span class="ok">OK</span>';
   statusText.textContent='loading models…';
   const fs = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
   face = await FaceLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"}, runningMode:'IMAGE', numFaces:5 });
   pose = await PoseLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task"}, runningMode:'IMAGE' });
   modelState.innerHTML='<span class="ok">OK</span>';
   statusText.textContent='ready';
 }catch(e){
   bundleState.innerHTML='<span class="bad">FAIL</span>';
   modelState.innerHTML='<span class="bad">FAIL</span>';
   statusText.textContent='init error';
 }
})();

/* ========= Steps ========= */
function setStep(n){ ['s1','s2','s3','s4'].forEach((id,i)=>document.getElementById(id).classList.toggle('active',(i+1)===n));
  // always keep the image visible on step change
  if(currentImage) drawImageLetterbox(currentImage);
}
setStep(1);

const file=document.getElementById('file');
const demo=document.getElementById('demo');
const goTo2=document.getElementById('goTo2');
const goTo3=document.getElementById('goTo3');
const goTo4=document.getElementById('goTo4');
const previewBtn=document.getElementById('preview');
const rerun=document.getElementById('rerun');

file.addEventListener('change', ()=>{
  const f=file.files?.[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image();
  img.onload=()=>{ currentImage=img; drawImageLetterbox(img); goTo2.disabled=false; URL.revokeObjectURL(url); toast('Image loaded to canvas.'); };
  img.onerror=()=>{ URL.revokeObjectURL(url); toast('Image load failed'); };
  img.src=url;
});

// Tiny demo image (not pretty, but proves path)
const demoPng="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANAAAADQCAYAAAD3QmL4AAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVR4nO3TwQmDQBQF0eT9T2iZgQq3Zy7y1qkH1bYw+5h4v5yKp1lGgAAAAAAAAAAAAAAAPzXr8nqGk9i2y3bG2wqk9gRz8yVwz5w7k1m0t0b3m4v0bq9wq3g5w4e3Qv6wz7P3vTgPpJkAAJ4w0n8C3q7v9v0FJr7nYt9b3x2cW3O2mXxg7iB9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ+eGgAA+S9cFf7r+f3bJrS6cV7fNw9u8s7xw7v+f2C6v7p/8eZ7c4+f3b8v7n+DDkAAE9h8gMAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAoB1B/0iJ7o9J0c9AAAAAElFTkSuQmCC";
demo.addEventListener('click', ()=>{ const img=new Image(); img.onload=()=>{ currentImage=img; drawImageLetterbox(img); goTo2.disabled=false; toast('Demo image loaded.'); }; img.src=demoPng; });

goTo2.addEventListener('click', ()=>setStep(2));
goTo3.addEventListener('click', ()=>setStep(3));
rerun.addEventListener('click', ()=>setStep(2));

/* ========= Tabs ========= */
document.querySelectorAll('.tab-head button').forEach(b=>{
  b.addEventListener('click',()=>{
    document.querySelectorAll('.tab-head button').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.getElementById('tab_'+b.dataset.tab).classList.add('active');
  });
});

/* ========= Basic analysis with visible overlay ========= */
const faceCountEl=document.getElementById('faceCount');
const activeFaceIdxEl=document.getElementById('activeFaceIdx');
const faceSelector=document.getElementById('faceSelector');
const outSFW=document.getElementById('outSFW');
const outNSFW=document.getElementById('outNSFW');
const outMeas=document.getElementById('outMeas');
const outJson=document.getElementById('outJson');
const copySFWBtn=document.getElementById('copySFW');
const copyNSFWBtn=document.getElementById('copyNSFW');
const exportJSON=document.getElementById('exportJSON');

const scanFace=document.getElementById('scanFace');
const scanBody=document.getElementById('scanBody');
const scanNSFW=document.getElementById('scanNSFW');
const useCloud=document.getElementById('useCloud');
const hfTokenEl=document.getElementById('hfToken');

let analysis=null;
let activeFaceIdx=0;

function renderOverlay(){
  ctxOver.clearRect(0,0,cOver.width,cOver.height);
  if(!analysis?.faces?.length) return;
  const d=new DrawingUtils(ctxOver);
  analysis.faces.forEach((f,i)=>{
    const col = i===activeFaceIdx ? 'rgba(100,242,227,.95)' : 'rgba(100,242,227,.35)';
    try{ d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_TESSELLATION, {color:col,lineWidth:.9}); }catch{}
    d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_LIPS,{color:'rgba(255,120,160,.9)',lineWidth:2});
    d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,{color:'rgba(140,255,220,.9)',lineWidth:2});
  });
}

function mkFacePills(){
  faceSelector.innerHTML='';
  (analysis.faces||[]).forEach((f,idx)=>{
    const pill=document.createElement('button');
    pill.className='btn';
    pill.textContent='Face '+idx;
    pill.addEventListener('click',()=>{activeFaceIdx=idx; activeFaceIdxEl.textContent=idx; renderOverlay(); buildOutputs();});
    faceSelector.appendChild(pill);
  });
}

function buildOutputs(){
  if(!analysis){ outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=''; return; }
  const f=analysis.faces?.[activeFaceIdx];
  if(!f){ outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=JSON.stringify(analysis,null,2); return; }
  outSFW.value=`portrait, ${f.shape} face, jaw/face ${f.ratios.jaw_face}, cheek/face ${f.ratios.cheek_face}, eye angle ${f.measures.eye_angle_deg}°, hair ${f.palette.hair}, skin ${f.palette.skin}, eyes ${f.palette.eyes}`;
  outNSFW.value = scanNSFW.checked ? (f.nsfw?.breast_size ? `${f.nsfw.breast_size} breasts, ${f.nsfw.nipples_visible?'visible nipples':'covered'}` : 'nsfw heuristics: none') : '';
  outMeas.value = `face H ${f.measures.face_height}px, jaw ${f.measures.jaw_width}px, cheek ${f.measures.cheek_width}px`;
  outJson.value = JSON.stringify(analysis,null,2);
  copySFWBtn.disabled=false; copyNSFWBtn.disabled=!scanNSFW.checked; exportJSON.disabled=false;
}

function dist(a,b,lm){ return Math.hypot(lm[a].x-lm[b].x, lm[a].y-lm[b].y); }
function eyeAngleDeg(lm){ const a=133,b=362; return +(Math.atan2(lm[b].y-lm[a].y, lm[b].x-lm[a].x)*180/Math.PI).toFixed(2); }
function bbox(lm){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of lm){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function classify(jaw_face,cheek_face){ if(jaw_face<0.45 && cheek_face<0.55) return 'oval'; if(Math.abs(jaw_face-cheek_face)<0.03 && jaw_face>0.5) return 'round'; if(jaw_face>=0.55 && cheek_face>=0.6) return 'square'; if(cheek_face>jaw_face+0.07) return 'heart'; return 'triangle'; }
function avgRectHex(imgData,W,H,x,y,w,h,step=2){ const d=imgData.data; const x0=Math.max(0,Math.floor(x)),y0=Math.max(0,Math.floor(y)),x1=Math.min(W,Math.floor(x+w)),y1=Math.min(H,Math.floor(y+h)); let r=0,g=0,b=0,c=0;
  for(let yy=y0;yy<y1;yy+=step){ for(let xx=x0;xx<x1;xx+=step){ const i=(yy*W+xx)*4; r+=d[i]; g+=d[i+1]; b+=d[i+2]; c++; } }
  if(!c) return '#000000'; r=(r/c)|0; g=(g/c)|0; b=(b/c)|0; return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
function backgroundTag(imgData,W,H){
  let gCnt=0,bCnt=0,wCnt=0,n=0; const d=imgData.data;
  const rgb2hsv=(r,g,b)=>{ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b), dif=max-min; let h=0; const s=max?dif/max:0; const v=max; if(dif){ switch(max){case r:h=(g-b)/dif+(g<b?6:0);break;case g:h=(b-r)/dif+2;break;case b:h=(r-g)/dif+4;break;} h/=6;} return [h*360,s,v]; };
  for(let y=0;y<H;y+=10){ for(let x=0;x<W;x+=10){ const i=(y*W+x)*4; const [h,s,v]=rgb2hsv(d[i],d[i+1],d[i+2]); n++; if(s>0.25 && v>0.15 && h>80 && h<160) gCnt++; if(s>0.2 && v>0.25 && ((h>170&&h<220))) bCnt++; if(s<0.1 && v>0.9) wCnt++; }}
  const green=gCnt/n, blue=bCnt/n, white=wCnt/n;
  if(green>0.25) return 'forest/foliage'; if(blue>0.25) return 'sky/water'; if(white>0.10) return 'bright/indoor'; return 'neutral';
}

async function previewOverlay(){
  if(!currentImage || !face){ toast('Load image first.'); return; }
  // Ensure canvas has the image (in case of any redraw)
  drawImageLetterbox(currentImage);
  const W=cPrev.width, H=cPrev.height;
  const imgPixels=ctxPrev.getImageData(0,0,W,H);

  // Detect faces from the canvas itself (simple & robust)
  const resF = await face.detect(cPrev).catch(()=>null);
  const allLm=(resF?.faceLandmarks)||[];
  faceCountEl.textContent=allLm.length;
  if(!allLm.length){ analysis=null; renderOverlay(); buildOutputs(); toast('No faces found.'); return; }

  const facesOut=[];
  for(let fi=0; fi<allLm.length; fi++){
    const lmN=allLm[fi];
    // Convert normalized into canvas coords based on imgFit
    const lmC = lmN.map(p=>({x:imgFit.dx + p.x*imgFit.dw, y:imgFit.dy + p.y*imgFit.dh, z:p.z}));
    const faceHpx=dist(10,152,lmC), jawWpx=dist(234,454,lmC), cheekWpx=dist(234,454,lmC);
    const eyeDeg=eyeAngleDeg(lmC);
    const ratios={jaw_face:+(jawWpx/faceHpx).toFixed(3), cheek_face:+(cheekWpx/faceHpx).toFixed(3)};
    const shape=classify(ratios.jaw_face, ratios.cheek_face);
    const bb=bbox(lmC); const fW=bb.maxX-bb.minX, fH=bb.maxY-bb.minY;
    const hair=avgRectHex(imgPixels,W,H, bb.minX, Math.max(0,bb.minY-12), fW, 10, 1);
    const skin=avgRectHex(imgPixels,W,H, bb.minX+0.35*fW, bb.minY+0.45*fH, 18,18, 1);
    const e=lmC[133]; const eyes=avgRectHex(imgPixels,W,H, e.x-8, e.y-8, 16,16, 1);
    facesOut.push({
      index:fi,
      measures:{face_height:+faceHpx.toFixed(2), jaw_width:+jawWpx.toFixed(2), cheek_width:+cheekWpx.toFixed(2), eye_angle_deg:eyeDeg},
      ratios, shape, palette:{hair,skin,eyes}, landmarks_canvas:lmC
    });
  }

  analysis={ version:"pf_facemapper_3_plus", frame:{type:"image"},
    image:{width:imgFit.dw, height:imgFit.dh, canvas:{W,H}},
    faces:facesOut, pose:null, scene:{bgTag:backgroundTag(imgPixels,W,H)}, cloud:null
  };
  activeFaceIdx=0; faceCountEl.textContent=facesOut.length; activeFaceIdxEl.textContent=facesOut.length?0:'—';
  mkFacePills(); renderOverlay(); buildOutputs();
}

document.getElementById('preview').addEventListener('click', previewOverlay);

/* ========= Full analysis (with optional cloud) ========= */
async function runAnalysis(){
  if(!currentImage || !face){ toast('Load image first.'); return; }
  // Guarantee the canvas holds the image now (even if resized)
  drawImageLetterbox(currentImage);
  await previewOverlay(); // local first; keeps UI responsive

  if(!useCloud.checked) return;

  const token=hfTokenEl.value.trim(); if(!token){ toast('Add HF token or disable cloud.'); return; }
  const blob = await new Promise(r=>cPrev.toBlob(r,'image/png',0.92));
  const hfPOST = async (modelId)=> {
    const r=await fetch(`https://api-inference.huggingface.co/models/${modelId}`,{
      method:'POST', headers:{'Authorization':`Bearer ${token}`}, body:blob
    });
    if(!r.ok) throw new Error(modelId+': '+r.status);
    return r.json();
  };
  let cloud={};
  try{
    const cap = await hfPOST('Salesforce/blip-image-captioning-large').catch(()=>null);
    const clip= await hfPOST('pharma/CLIP-Interrogator').catch(()=>null);
    const detr= await hfPOST('facebook/detr-resnet-50').catch(()=>null);
    cloud.caption = cap?.[0]?.generated_text || null;
    cloud.clip_prompt = clip?.[0]?.generated_text || clip?.generated_text || null;
    cloud.objects = detr || null;
  }catch(e){ cloud.error=String(e); }
  analysis.cloud = cloud;
  buildOutputs();
}
document.getElementById('goTo4').addEventListener('click', ()=>{ setStep(4); runAnalysis(); });

/* ========= Buttons ========= */
document.getElementById('copySFW').addEventListener('click',()=>navigator.clipboard.writeText(outSFW.value||'').then(()=>toast('Copied SFW')));
document.getElementById('copyNSFW').addEventListener('click',()=>navigator.clipboard.writeText(outNSFW.value||'').then(()=>toast('Copied NSFW')));
document.getElementById('exportJSON').addEventListener('click',()=>{
  const blob=new Blob([outJson.value||'{}'],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='mapper_wizard.json'; document.body.appendChild(a); a.click();
  setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);},150);
});

/* ========= Step nav keeps canvas content visible ========= */
document.getElementById('goTo2').addEventListener('click',()=>setStep(2));
document.getElementById('goTo3').addEventListener('click',()=>setStep(3));

/* ========= Small UX: enable copy/export when analysis exists ========= */
const observer=new MutationObserver(()=>{ const has=!!analysis; document.getElementById('copySFW').disabled=!has; document.getElementById('exportJSON').disabled=!has; document.getElementById('copyNSFW').disabled=!(has && document.getElementById('scanNSFW').checked); });
observer.observe(document.getElementById('tab_json'),{subtree:true,childList:true,characterData:true});
</script>
</body>
</html>
