<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PF — ImageIntel Pro Visor (Face • Pose • Segments • NSFW • Cloud)</title>
<meta name="robots" content="noindex,nofollow"/>
<meta name="description" content="On-device MediaPipe face mesh, full-body pose, multiclass segmentation, and an animated HUD that reveals the scanning process. Optional NSFW part labels and Hugging Face caption/objects.">
<style>
:root{
  --bg:#0b0f14; --ink:#eaf9ff; --dim:#93a8b5; --edge:#22303b;
  --aqua:#64f2e3; --vio:#be9cff; --pink:#ff78a0; --gold:#ffd166; --ok:#55d69a; --bad:#ff6b6b;
}
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:ui-monospace,Menlo,Consolas,monospace}
.wrap{max-width:1240px;margin:0 auto;padding:16px}
h1{margin:0 0 10px;font-size:1.12rem}
small,.note{color:var(--dim)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
.badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0d141add}
.ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--gold)}
.btn{cursor:pointer;border:1.5px solid var(--aqua);background:#131a22;color:#b8fff6;padding:8px 12px;border-radius:10px;font-weight:700}
.btn:hover{background:var(--aqua);color:#071017;border-color:#fff}
.btn:disabled{opacity:.5;cursor:not-allowed}

.stage{position:relative;border:1px solid var(--edge);border-radius:12px;background:#0e151d;overflow:hidden}
.inner{position:relative;width:100%;aspect-ratio:16/9}
#img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;user-select:none;-webkit-user-drag:none}
canvas{position:absolute;inset:0;pointer-events:none}
#mesh{filter:drop-shadow(0 0 9px #64f2e344)}
#hud{mix-blend-mode:screen}
.grid{position:absolute;inset:0;background-image:linear-gradient(#64f2e31c 1px,transparent 1px),linear-gradient(90deg,#64f2e31c 1px,transparent 1px);background-size:40px 40px;opacity:.22;pointer-events:none}
.scanbar{position:absolute;left:0;right:0;height:3px;background:linear-gradient(90deg,transparent,#64f2e3,transparent);box-shadow:0 0 10px #64f2e3aa;opacity:0;pointer-events:none;transition:opacity .12s ease}

.legend{position:absolute;left:12px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:10}
.hl{position:absolute;padding:2px 6px;border-radius:6px;font-size:.8rem;background:#0f2130cc;border:1px solid #2a3a46;color:#c8f6ff}
.box{position:absolute;border:2px dashed rgba(190,156,255,.95);box-shadow:0 0 10px #be9cff55 inset}
.seg-dot{position:absolute;width:6px;height:6px;border-radius:50%;background:#ff78a055;border:1px solid #ff78a0}

.stepper{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin:12px 0}
.step{border:1px solid var(--edge);border-radius:10px;padding:10px;background:#0f161f}
.step.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.option{display:flex;align-items:center;gap:8px;margin:6px 0}
input[type="checkbox"],input[type="radio"]{transform:scale(1.1)}
input[type="range"]{accent-color:var(--aqua)}
input[type="text"]{border:1px solid var(--edge);background:#0f141a;color:#fff;padding:6px 10px;border-radius:8px;min-width:320px}

.cols{display:grid;grid-template-columns:1fr 380px;gap:12px}
.term{background:#070c12;border:1px solid #14202b;border-radius:10px;padding:10px;min-height:260px;color:#bfeaff;max-height:420px;overflow:auto}
.term pre{margin:0;white-space:pre-wrap;line-height:1.25}
.term .prompt{color:#7ee3ff} .term .ok{color:#6dffb8} .term .err{color:#ff9a9a} .term .dim{color:#8aa6b3}

.tabs{margin-top:14px}
.tab-head{display:flex;flex-wrap:wrap;gap:8px}
.tab-head button{cursor:pointer;border:1px solid var(--edge);background:#0e141a;color:#fff;padding:8px 12px;border-radius:9px}
.tab-head button.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.tab{display:none;margin-top:10px;border:1px solid var(--edge);border-radius:12px;padding:12px;background:#0e141a}
.tab.active{display:block}
textarea.out{width:100%;min-height:140px;background:#0b1117;color:#d8faff;border:1px solid #1b242e;border-radius:8px;padding:10px}
.kv{display:grid;grid-template-columns:140px 1fr;gap:6px 10px}
.bar{height:6px;border:1px solid #2a3845;background:#0c1620;border-radius:8px;overflow:hidden}
.bar>i{display:block;height:100%;background:linear-gradient(90deg,#64f2e3,#be9cff)}
</style>
</head>
<body>
<div class="wrap">
  <h1>ImageIntel Pro Visor — Face • Pose • Segments • NSFW • Cloud</h1>

  <div class="row">
    <span class="badge">Status: <b id="status">booting…</b></span>
    <span class="badge">Bundle: <b id="bundle">—</b></span>
    <span class="badge">Models: <b id="models">—</b></span>
  </div>

  <div class="stage">
    <div class="inner" id="stage">
      <img id="img" alt=""/>
      <canvas id="mesh"></canvas>
      <canvas id="hud"></canvas>
      <div class="grid" id="grid"></div>
      <div class="scanbar" id="scan"></div>
      <div class="legend">
        <span class="badge">faces: <span id="faceCount">0</span></span>
        <span class="badge">pose: <span id="poseState">off</span></span>
        <span class="badge">tiles: <span id="tileState">0%</span></span>
      </div>
    </div>
  </div>

  <div class="stepper">
    <div class="step active" id="st1">
      <h3>Step 1 — Load</h3>
      <div class="option">
        <input id="file" type="file" accept="image/*"/>
        <button class="btn" id="demo">Load Demo</button>
      </div>
      <div class="row"><button class="btn" id="to2" disabled>Next</button></div>
    </div>
    <div class="step" id="st2">
      <h3>Step 2 — Options</h3>
      <div class="option"><input type="checkbox" id="optFace" checked> <label for="optFace">Face mesh (468 tessellation)</label></div>
      <div class="option"><input type="checkbox" id="optPose" checked> <label for="optPose">Body pose (labeled skeleton)</label></div>
      <div class="option"><input type="checkbox" id="optSeg" checked> <label for="optSeg">People parts segmentation (hair / face-skin / body-skin / clothes)</label></div>
      <div class="option"><input type="checkbox" id="optNSFW"> <label for="optNSFW">NSFW part detector (exposed regions)</label></div>
      <div class="option"><input type="checkbox" id="optObjects"> <label for="optObjects">Objects + style hint (cloud)</label></div>
      <div class="option"><label>Detail <input id="detail" type="range" min="1" max="3" step="1" value="3"></label></div>
      <div class="option"><label>Spice <input id="spice" type="range" min="0" max="3" step="1" value="2"></label></div>
      <div class="row">
        <button class="btn" id="preview" disabled>Preview Overlay</button>
        <button class="btn" id="to3" disabled>Next</button>
      </div>
    </div>
    <div class="step" id="st3">
      <h3>Step 3 — Cloud Assist (optional)</h3>
      <div class="option"><input type="checkbox" id="useCloud"> <label for="useCloud">Hugging Face (caption/CLIP + DETR boxes)</label></div>
      <div class="option"><input id="hfToken" type="text" placeholder="hf_... token"/></div>
      <div class="row"><button class="btn" id="run" disabled>Run Analysis</button></div>
    </div>
  </div>

  <div class="cols">
    <div>
      <div class="tabs">
        <div class="tab-head">
          <button class="active" data-tab="sfw">SFW Prompt</button>
          <button data-tab="nsfw">NSFW Prompt</button>
          <button data-tab="json">JSON</button>
          <button data-tab="diag">Diagnostics</button>
        </div>
        <div class="tab active" id="tab_sfw"><textarea id="outSFW" class="out" readonly></textarea></div>
        <div class="tab" id="tab_nsfw"><textarea id="outNSFW" class="out" readonly></textarea></div>
        <div class="tab" id="tab_json"><textarea id="outJSON" class="out" readonly></textarea></div>
        <div class="tab" id="tab_diag">
          <div class="kv">
            <div>UA</div><div id="ua"></div>
            <div>Image</div><div id="imgInfo"></div>
            <div>Canvas</div><div id="canInfo"></div>
            <div>Bust/Waist/Hips</div><div><div class="bar"><i id="bwh" style="width:0%"></i></div></div>
          </div>
        </div>
      </div>
    </div>
    <div class="term"><pre id="termOut"><span class="dim">[boot]</span> ImageIntel Pro visor starting…</pre></div>
  </div>
</div>

<script type="module">
/* ================= Imports (pinned) ================= */
import { FilesetResolver, FaceLandmarker, PoseLandmarker, ImageSegmenter, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs"; // Face/Pose/Segmenter/DrawingUtils (Web) :contentReference[oaicite:4]{index=4}

/* ================= Tiny helpers ================= */
const $=(q,p=document)=>p.querySelector(q), $$=(qa,p=document)=>Array.from(p.querySelectorAll(qa));
const print=(s,cls='')=>{ const pre=$("#termOut"); pre.innerHTML += "\\n" + (cls?`<span class="${cls}">${s}</span>`:s); pre.parentElement.scrollTop = pre.parentElement.scrollHeight; };
const setStep=(n)=>["st1","st2","st3"].forEach((id,i)=>$("#"+id).classList.toggle("active",i===n-1));
$$(".tab-head button").forEach(b=>b.addEventListener("click",()=>{ $$(".tab-head button").forEach(x=>x.classList.remove("active")); b.classList.add("active"); $$(".tab").forEach(x=>x.classList.remove("active")); $("#tab_"+b.dataset.tab).classList.add("active"); }));

/* ================= DOM refs ================= */
const statusEl=$("#status"), bundleEl=$("#bundle"), modelsEl=$("#models");
const img=$("#img"), mesh=$("#mesh"), hud=$("#hud"), mctx=mesh.getContext('2d'), hctx=hud.getContext('2d');
const stage=$("#stage"), scan=$("#scan"), grid=$("#grid");
const faceCountEl=$("#faceCount"), poseStateEl=$("#poseState"), tileStateEl=$("#tileState");
const file=$("#file"), demo=$("#demo"), to2=$("#to2"), to3=$("#to3"), preview=$("#preview"), run=$("#run");
const optFace=$("#optFace"), optPose=$("#optPose"), optSeg=$("#optSeg"), optNSFW=$("#optNSFW"), optObjects=$("#optObjects");
const detail=$("#detail"), spice=$("#spice"), useCloud=$("#useCloud"), hfToken=$("#hfToken");
const outSFW=$("#outSFW"), outNSFW=$("#outNSFW"), outJSON=$("#outJSON");
$("#ua").textContent = navigator.userAgent;

let imgBox={x:0,y:0,w:0,h:0}, imgNatural={w:0,h:0};

/* ================= Model paths ================= */
// Face & Pose official task models (GCS)
const FACE_MODEL="https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task";
const POSE_MODEL="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";
// Multi-class Selfie segmentation (hair, face-skin, body-skin, clothes, accessories) path used by the MP team in issue threads:
const SEG_MODEL="https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_multiclass_256x256/float32/latest/selfie_multiclass_256x256.tflite"; // classes like hair/body-skin/face-skin/clothes. :contentReference[oaicite:5]{index=5}

/* ================= Instances ================= */
let face=null, pose=null, seg=null, DU=null;
let faceRes=null, poseRes=null, segRes=null, nsfwRes=null, clipHint=null, objects=null;

/* ================= Sizing & alignment ================= */
function syncOverlay(){
  const ri=img.getBoundingClientRect(), rs=stage.getBoundingClientRect();
  imgBox={ x:Math.round(ri.left-rs.left), y:Math.round(ri.top-rs.top), w:Math.round(ri.width), h:Math.round(ri.height) };
  [mesh,hud].forEach(c=>{ c.style.left=imgBox.x+"px"; c.style.top=imgBox.y+"px"; c.width=Math.max(1,imgBox.w); c.height=Math.max(1,imgBox.h); });
  $("#canInfo").textContent = `${mesh.width}×${mesh.height}`;
}
new ResizeObserver(syncOverlay).observe(stage);
addEventListener("scroll",()=>{ if(img.src){ syncOverlay(); drawAllImmediate(); } },{passive:true});

/* ================= Init ================= */
(async()=>{
  try{
    statusEl.textContent="loading…"; print("$ visor init","prompt");
    const fs = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
    bundleEl.innerHTML='<span class="ok">OK</span>'; print("vision bundle: ok","ok");

    face = await FaceLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:FACE_MODEL}, runningMode:"IMAGE", numFaces:5 });
    pose = await PoseLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:POSE_MODEL}, runningMode:"IMAGE" });
    // ImageSegmenter can be created from model path; we enable category mask output.
    seg  = await ImageSegmenter.createFromOptions(fs,{ baseOptions:{modelAssetPath:SEG_MODEL}, runningMode:"IMAGE", outputCategoryMask:true }); // :contentReference[oaicite:6]{index=6}
    DU   = new DrawingUtils(mctx);

    modelsEl.innerHTML='<span class="ok">OK</span>'; statusEl.textContent="ready"; print("models: face+pose+segmenter ready","ok");
  }catch(e){ modelsEl.innerHTML='<span class="bad">error</span>'; statusEl.textContent="init failed"; print(String(e),"err"); }
})();

/* ================= Load image ================= */
function enable(){ preview.disabled=false; to3.disabled=false; run.disabled=false; }
file.addEventListener("change", ()=>{
  const f=file.files?.[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  img.onload=()=>{ imgNatural={w:img.naturalWidth,h:img.naturalHeight}; $("#imgInfo").textContent=`${imgNatural.w}×${imgNatural.h}`; syncOverlay(); to2.disabled=false; enable(); print(`loaded file: ${f.name}  ${imgNatural.w}x${imgNatural.h}`,"dim"); URL.revokeObjectURL(url); };
  img.src=url; img.alt=f.name||"image";
});
demo.addEventListener("click", ()=>{
  img.onload=()=>{ imgNatural={w:img.naturalWidth,h:img.naturalHeight}; $("#imgInfo").textContent=`${imgNatural.w}×${imgNatural.h}`; syncOverlay(); to2.disabled=false; enable(); print("demo portrait loaded","dim"); };
  img.crossOrigin="anonymous"; img.src="https://storage.googleapis.com/mediapipe-assets/portrait.jpg";
});
to2.addEventListener("click",()=>setStep(2));
to3.addEventListener("click",()=>setStep(3));

/* ================= Clean & labels ================= */
function clearHUD(){ mctx.clearRect(0,0,mesh.width,mesh.height); hctx.clearRect(0,0,hud.width,hud.height); $$(".hl",stage).forEach(n=>n.remove()); $$(".box",stage).forEach(n=>n.remove()); $$(".seg-dot",stage).forEach(n=>n.remove()); }
function label(x,y,t,bg="#0f2130cc"){ const el=document.createElement('div'); el.className='hl'; el.textContent=t; el.style.left=(imgBox.x+x)+"px"; el.style.top=(imgBox.y+y)+"px"; el.style.background=bg; stage.appendChild(el); return el; }
function box(x,y,w,h,t){ const el=document.createElement('div'); el.className='box'; el.style.left=(imgBox.x+x)+"px"; el.style.top=(imgBox.y+y)+"px"; el.style.width=w+"px"; el.style.height=h+"px"; stage.appendChild(el); if(t){ const L=label(x+4,y+4,t,"#1b0f25cc"); } return el; }
function segDot(x,y){ const d=document.createElement('div'); d.className='seg-dot'; d.style.left=(imgBox.x+x-3)+'px'; d.style.top=(imgBox.y+y-3)+'px'; stage.appendChild(d); }

/* ================= Drawing ================= */
function drawFaceFancy(){
  if(!optFace.checked || !faceRes?.faceLandmarks?.length) return;
  mctx.clearRect(0,0,mesh.width,mesh.height);
  for(const lm of faceRes.faceLandmarks){
    DU.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_TESSELLATION, {color:"rgba(100,242,227,.42)", lineWidth:1});
    DU.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,   {color:"rgba(140,255,220,.98)", lineWidth:2});
    DU.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE,   {color:"#fff", lineWidth:2});
    DU.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,    {color:"#fff", lineWidth:2});
    DU.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LIPS,        {color:"rgba(255,120,160,.98)", lineWidth:2});
    // glow dots
    mctx.save(); mctx.fillStyle="rgba(190,156,255,.95)"; mctx.shadowColor="#be9cff"; mctx.shadowBlur=14;
    [33,133,362,263,1,13,14].forEach(i=>{ const p=lm[i]; mctx.beginPath(); mctx.arc(p.x*mesh.width,p.y*mesh.height,2.6,0,Math.PI*2); mctx.fill(); });
    mctx.restore();
    // labels
    const R=k=>({x:lm[k].x*mesh.width,y:lm[k].y*mesh.height});
    const lip=R(13), chin=R(152), brow=R(10);
    label(lip.x+6, lip.y-10, "lips");
    label(chin.x+6, chin.y+4 , "jaw");
    label(brow.x+6, brow.y-8 , "brow");
  }
}
const POSE_LINKS=[[11,13,15],[12,14,16],[11,12],[23,24],[11,23],[12,24],[23,25,27],[24,26,28]];
function drawPoseLabeled(){
  if(!optPose.checked || !poseRes?.landmarks?.length) return;
  const lm=poseRes.landmarks[0];
  hctx.save(); hctx.clearRect(0,0,hud.width,hud.height); hctx.strokeStyle="rgba(190,156,255,.95)"; hctx.lineWidth=2.2; hctx.beginPath();
  const P=i=>[lm[i].x*hud.width, lm[i].y*hud.height];
  for(const chain of POSE_LINKS){ for(let i=0;i<chain.length-1;i++){ const [x1,y1]=P(chain[i]), [x2,y2]=P(chain[i+1]); hctx.moveTo(x1,y1); hctx.lineTo(x2,y2); } }
  hctx.stroke(); hctx.restore();
  const S=P(11), R=P(12), H1=P(23), H2=P(24);
  label((S[0]+R[0])/2-28,(S[1]+R[1])/2-8,"shoulders");
  label((H1[0]+H2[0])/2-14,(H1[1]+H2[1])/2-6,"hips");
}

/* ================= Segmentation (multiclass) ================= */
// class indices (documented by community & guides): 0 bg, 1 hair, 2 body-skin, 3 face-skin, 4 clothes, 5 accessories. :contentReference[oaicite:7]{index=7}
const SEG_LABELS=["background","hair","body-skin","face-skin","clothes","accessories"];
function drawSegmentationAnimated(){
  if(!optSeg.checked || !segRes?.categoryMask) return;
  const W=mesh.width, H=mesh.height;
  const mask=segRes.categoryMask.getAsUint8Array(); // one byte per pixel (class id)
  const tile=40; let yi=0;

  (function pass(){
    const row=Math.min(H, yi+tile);
    for(let y=yi; y<row; y+=4){
      for(let x=0; x<W; x+=4){
        const idx=y*W+x; const cls=mask[idx];
        if(cls===1){ // hair
          mctx.fillStyle="rgba(190,156,255,.18)"; mctx.fillRect(x,y,4,4); if((x+y)%80===0) segDot(x,y);
        }else if(cls===2||cls===3){ // body/face skin
          mctx.fillStyle="rgba(255,120,160,.14)"; mctx.fillRect(x,y,4,4);
        }else if(cls===4){ // clothes
          mctx.fillStyle="rgba(100,242,227,.10)"; mctx.fillRect(x,y,4,4);
        }
      }
    }
    yi += tile; tileStateEl.textContent = Math.round(yi/H*100)+"%";
    if(yi < H){ setTimeout(pass, 700/Math.ceil(H/tile)); }
  })();
}

/* ================= Preview (phased) ================= */
preview.addEventListener("click", async ()=>{
  if(!img.src){ alert("Load an image first."); return; }
  clearHUD(); syncOverlay();
  print("$ preview --run","prompt");

  // Face (sync)
  try{ faceRes = optFace.checked ? face.detect(img) : null; }catch(e){ faceRes=null; print("face.detect: "+(e?.message||e),"err"); }
  faceCountEl.textContent = faceRes?.faceLandmarks?.length || 0;

  // Scanline sweep while drawing face
  scan.style.opacity='1'; scan.style.top=imgBox.y+'px';
  let y=imgBox.y, end=imgBox.y+imgBox.h;
  await new Promise(res=>{
    (function step(){ if(y>=end){ scan.style.opacity='0'; return res(); }
      y += Math.max(3, imgBox.h/28); scan.style.top=y+'px';
      drawFaceFancy(); requestAnimationFrame(step);
    })();
  });
  print("face mesh: ok","ok");

  // Pose (sync)
  try{ poseRes = optPose.checked ? pose.detect(img) : null; }catch(e){ poseRes=null; print("pose.detect: "+(e?.message||e),"err"); }
  poseStateEl.textContent = poseRes?.landmarks?.length ? "on" : "off";
  drawPoseLabeled(); print("pose: "+(poseRes?.landmarks?.length?"ok":"none"), poseRes?.landmarks?.length?"ok":"dim");

  // Segmentation (sync)
  try{ segRes = optSeg.checked ? seg.segment(img) : null; }catch(e){ segRes=null; print("segment: "+(e?.message||e),"err"); }
  if(segRes?.categoryMask){ drawSegmentationAnimated(); print("segments: hair/skin/clothes","ok"); }

  to3.disabled=false; run.disabled=false;
});

/* ================= Tools for measurements & palette ================= */
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function colorWord(hex){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  const max=Math.max(r,g,b), min=Math.min(r,g,b); const v=max/255, s=max? (max-min)/max : 0;
  let h=0; if(max!==min){ const d=max-min; if(max===r) h=(g-b)/d+(g<b?6:0); else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; }
  if(v<0.15) return "black"; if(s<0.15) return v>0.85?"porcelain":"light";
  if(h<15||h>345) return "red"; if(h<45) return "golden"; if(h<75) return "blonde"; if(h<150) return "green"; if(h<220) return "blue"; if(h<275) return "purple"; if(h<330) return "magenta"; return "brown";
}
function sampleHex(ctx,x,y,w,h,step=2){ const W=ctx.canvas.width,H=ctx.canvas.height; const x0=Math.max(0,Math.floor(x)),y0=Math.max(0,Math.floor(y)),x1=Math.min(W,Math.floor(x+w)),y1=Math.min(H,Math.floor(y+h));
  const d=ctx.getImageData(x0,y0,x1-x0,y1-y0).data; let R=0,G=0,B=0,c=0; for(let i=0;i<d.length;i+=4*step){ R+=d[i]; G+=d[i+1]; B+=d[i+2]; c++; } R=(R/c|0); G=(G/c|0); B=(B/c|0); return "#"+[R,G,B].map(v=>v.toString(16).padStart(2,"0")).join(""); }

/* ================= Analysis + Replica Prompt ================= */
run.addEventListener("click", async ()=>{
  if(!img.src){ alert("Load an image first."); return; }
  print("$ analyze --assemble","prompt");

  // Ensure local results
  if(!faceRes) try{ faceRes= face.detect(img); }catch{}
  if(!poseRes && optPose.checked) try{ poseRes= pose.detect(img); }catch{}
  if(!segRes  && optSeg.checked ) try{ segRes = seg.segment(img); }catch{}

  // Measurements (first face)
  const faces=[];
  if(faceRes?.faceLandmarks?.length){
    const lm=faceRes.faceLandmarks[0];
    const L=k=>({x:lm[k].x*mesh.width, y:lm[k].y*mesh.height});
    const Fh=dist(L(10),L(152)), Jw=dist(L(234),L(454)), Cw=dist(L(234),L(454));
    const eyeDeg=(Math.atan2(L(362).y-L(133).y, L(362).x-L(133).x)*180/Math.PI);
    const ratios={jaw_face:+(Jw/Fh).toFixed(3), cheek_face:+(Cw/Fh).toFixed(3)};
    let shape='oval'; if(ratios.jaw_face>=0.55 && ratios.cheek_face>=0.6) shape='square'; else if(Math.abs(ratios.jaw_face-ratios.cheek_face)<0.03 && ratios.jaw_face>0.5) shape='round';

    // palettes
    const snap=document.createElement('canvas'); snap.width=mesh.width; snap.height=mesh.height; const sc=snap.getContext('2d'); sc.drawImage(img,0,0,mesh.width,mesh.height);
    // hair zone: band above forehead
    const xs=lm.map(p=>p.x), ys=lm.map(p=>p.y); const bb={x:Math.min(...xs)*mesh.width,y:Math.min(...ys)*mesh.height,w:(Math.max(...xs)-Math.min(...xs))*mesh.width,h:(Math.max(...ys)-Math.min(...ys))*mesh.height};
    const hairHex = sampleHex(sc, bb.x, Math.max(0,bb.y-12), bb.w, 12, 1);
    const skinHex = sampleHex(sc, bb.x+0.4*bb.w, bb.y+0.45*bb.h, 16,16,1);
    const eyeHex  = sampleHex(sc, L(133).x-8, L(133).y-8, 16,16,1);

    faces.push({
      measures:{face_height:+Fh.toFixed(1), jaw_width:+Jw.toFixed(1), cheek_width:+Cw.toFixed(1), eye_angle_deg:+eyeDeg.toFixed(2)},
      ratios, shape,
      palette:{hair:hairHex, eyes:eyeHex, skin:skinHex, hairWord:colorWord(hairHex), skinWord:colorWord(skinHex), eyeWord:colorWord(eyeHex)}
    });
  }

  // Bust / Waist / Hips from segmentation scanlines
  let body=null;
  if(segRes?.categoryMask && poseRes?.landmarks?.length){
    const mask=segRes.categoryMask.getAsUint8Array();
    const W=mesh.width, H=mesh.height;
    const lm=poseRes.landmarks[0];
    const yShoulder = (lm[11].y+lm[12].y)/2*H;
    const yHips     = (lm[23].y+lm[24].y)/2*H;
    const yChest = yShoulder + 24, yWaist = (yShoulder+yHips)/2, yHipLine = yHips+10;

    function widthAt(y, classes=[2,3]){ // body/face skin
      y=Math.max(0,Math.min(H-1, Math.round(y)));
      let minX=W, maxX=0;
      for(let x=0;x<W;x++){
        const cls = mask[y*W+x];
        if(classes.includes(cls)){ minX=Math.min(minX,x); maxX=Math.max(maxX,x); }
      }
      return maxX>minX? maxX-minX : 0;
    }
    const bustW=widthAt(yChest), waistW=widthAt(yWaist), hipW=widthAt(yHipLine);
    $("#bwh").style.width = Math.min(100, (bustW&&hipW? ( (bustW/Math.max(1,waistW))*22 + (hipW/Math.max(1,waistW))*22 ) : 0 ))+"%";
    body={ spans_px:{shoulders:Math.hypot(lm[12].x*W-lm[11].x*W, lm[12].y*H-lm[11].y*H), bust:bustW, waist:waistW, hips:hipW} };
    // draw guide lines:
    hctx.strokeStyle="rgba(100,242,227,.7)"; [yChest,yWaist,yHipLine].forEach((y,i)=>{ hctx.beginPath(); hctx.moveTo(0,y); hctx.lineTo(W,y); hctx.stroke(); label(W*0.8+6, y-10, ["chest","waist","hips"][i]); });
  }

  // Optional NSFW (NudeNet) — only if toggle is on
  nsfwRes=null;
  if(optNSFW.checked){
    try{
      print("$ nsfw --nudenet","prompt");
      const { default: NudeNet } = await import("https://cdn.jsdelivr.net/gh/vladmandic/nudenet@main/dist/browser/nudenet.min.js"); // labels like exposed breasts/vagina/buttocks. :contentReference[oaicite:8]{index=8}
      const nn = new NudeNet();
      const t=document.createElement('canvas'); t.width=imgBox.w; t.height=imgBox.h; t.getContext('2d').drawImage(img,0,0,t.width,t.height);
      const det = await nn.detect(t); // [{label,score,box:[x,y,w,h]}]
      nsfwRes = det;
      det.slice(0,10).forEach(o=>box(o.box[0],o.box[1],o.box[2],o.box[3], `${o.label} ${(o.score*100|0)}%`));
      print("nsfw: "+det.length+" regions","ok");
    }catch(e){ print("nsfw: "+(e?.message||e),"err"); }
  }

  // Optional cloud (CLIP hint + DETR objects)
  clipHint=null; objects=null;
  if(useCloud.checked && hfToken.value.trim() && optObjects.checked){
    print("$ cloud --huggingface (clip+DETR)","prompt");
    try{
      const { HfInference } = await import("https://cdn.jsdelivr.net/npm/@huggingface/inference@2.8.0/+esm"); // official HF client :contentReference[oaicite:9]{index=9}
      const hf=new HfInference(hfToken.value.trim());
      const t=document.createElement('canvas'); t.width=imgBox.w; t.height=imgBox.h; t.getContext('2d').drawImage(img,0,0,t.width,t.height);
      const blob=await new Promise(r=>t.toBlob(r,'image/png',0.92));
      try{ const ci=await hf.imageToText({data:blob, model:"pharmapsychotic/clip-interrogator"}); clipHint=ci?.generated_text||null; print("clip-hint ✓","ok"); }catch(e){ print("clip-hint × "+(e?.message||e),"err"); } // :contentReference[oaicite:10]{index=10}
      try{ objects=await hf.objectDetection({data:blob, model:"facebook/detr-resnet-50"}); objects?.slice(0,12).forEach(o=>box(o.box.xmin,o.box.ymin,o.box.xmax-o.box.xmin,o.box.ymax-o.box.ymin,`${o.label} ${(o.score*100|0)}%`)); print("detr ✓","ok"); }catch(e){ print("detr × "+(e?.message||e),"err"); } // :contentReference[oaicite:11]{index=11}
    }catch(e){ print("cloud init: "+(e?.message||e),"err"); }
  }

  /* ======= Build Replica Prompt ======= */
  const dl=+detail.value, sp=+spice.value;
  const f=faces[0];
  const cameraAngle = "frontal portrait"; // simple heuristic placeholder; can refine via ear disparity
  const lighting = clipHint?.match(/(studio|soft|natural|candle|rim) light/i)?.[0]?.toLowerCase() || "natural light";
  const bgTag = objects?.some?.(o=>/tree|grass|field/i.test(o.label))?"forest/foliage":"neutral";

  const sfw = f ? [
    "portrait photo", 
    "photorealistic",
    `${f.shape} face`,
    `jaw/face ${f.ratios.jaw_face}, cheek/face ${f.ratios.cheek_face}`,
    `eye tilt ${f.measures.eye_angle_deg}°`,
    `${f.palette.hairWord} hair, ${f.palette.eyeWord} eyes, ${f.palette.skinWord} skin`,
    cameraAngle, lighting, bgTag,
    dl>=2?"balanced exposure, realistic texture":null,
    dl>=3?"sharp micro-detail, minimal distortion":null,
    clipHint?`style hint: ${clipHint}`:null
  ].filter(Boolean).join(", ") : "portrait, photorealistic, natural light";

  // NSFW replica (opt-in)
  let nsfwPrompt="";
  if(optNSFW.checked && f){
    // crude breast size from bust/face; better if NudeNet estimates exist
    let breastSize = body?.spans_px?.bust && f?.measures?.face_height
      ? (body.spans_px.bust/f.measures.face_height<1.55?'small':(body.spans_px.bust/f.measures.face_height<2.05?'medium':'large'))
      : "natural";
    const nippleFlag = nsfwRes?.some?.(o=>/breast/i.test(o.label));
    nsfwPrompt = [
      "nude portrait",
      `${f.shape} face`,
      `${breastSize} breasts${nippleFlag?", nipples visible":""}`,
      `${f.palette.skinWord} skin, ${f.palette.hairWord} hair`,
      lighting, sp>=2?"explicit body focus":"soft body focus", sp>=3?"dirty slang details":null
    ].filter(Boolean).join(", ");
  }

  const negative = "lowres, bad anatomy, extra limbs, deformed hands, oversharpen, cartoonish, unrealistic skin, fused features, duplicate face";

  const analysis = {
    version:"pf_imageintel_v4",
    image:{natural:imgNatural, box:imgBox},
    face:f||null,
    body:body,
    nsfw:{enabled:!!optNSFW.checked, detections:nsfwRes||[]},
    scene:{bgTag, lighting},
    cloud:{clip_hint:clipHint, objects:objects},
    prompts:{sfw, nsfw:nsfwPrompt, negative}
  };
  outSFW.value = sfw;
  outNSFW.value = nsfwPrompt;
  outJSON.value = JSON.stringify(analysis,null,2);
  print("assemble: done","ok");
});

/* ================= Draw on resize ================= */
function drawAllImmediate(){ clearHUD(); drawFaceFancy(); drawPoseLabeled(); if(segRes?.categoryMask) drawSegmentationAnimated(); }

/* ================= Enable buttons when image is ready ================= */
function enableAll(){ preview.disabled=false; to3.disabled=false; run.disabled=false; }
document.addEventListener("DOMContentLoaded",()=>{ print("ready.","ok"); });
</script>
</body>
</html>
