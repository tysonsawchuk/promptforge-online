<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PF FaceMapper — Prompt Lab (IMAGE → Prompt + Measures)</title>
<meta name="description" content="On-device face mapper + prompt generator. SFW and password-gated NSFW descriptors. Numeric measures, ratios, JSON export.">

<style>
  :root { --bg:#0b0f14; --ink:#d6f5ff; --edge:#232a33; --aqua:#64f2e3; --vio:#be9cff; --bad:#ff6b6b; --ok:#55d69a; --warn:#ffd166; --dim:#9db1bd; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:ui-monospace, Menlo, Consolas, monospace}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:0 0 10px 0;font-size:1.1rem;letter-spacing:.3px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
  .btn{cursor:pointer;border:1.5px solid var(--aqua);background:#131922;color:#b8fff6;padding:8px 12px;border-radius:10px;font-weight:700}
  .btn:hover{background:var(--aqua);color:#0e131a;border-color:#fff}
  #status{padding:8px 10px;border:1px solid var(--edge);border-radius:8px;display:inline-block;background:#0e141a}
  .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
  .stage{position:relative;border:1px solid var(--edge);border-radius:12px;background:#0d131a;overflow:hidden}
  .inner{position:relative;aspect-ratio:16/9}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  .mower{position:absolute;inset:0;background:linear-gradient(0deg,transparent 0%,rgba(255,255,255,.07) 50%,transparent 100%);
    background-size:100% 32%;animation:mow 1.6s linear infinite;mix-blend-mode:screen;opacity:.32;pointer-events:none}
  @media (prefers-reduced-motion: reduce){ .mower{animation:none;opacity:.12} }
  @keyframes mow{0%{background-position-y:100%}100%{background-position-y:0%}}
  .legend{position:absolute;left:12px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
  .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0b1117dd}
  .kv{display:grid;grid-template-columns:180px 1fr;gap:6px 14px}

  .tabs{margin-top:14px}
  .tab-head{display:flex;flex-wrap:wrap;gap:8px}
  .tab-head button{cursor:pointer;border:1px solid var(--edge);background:#0e141a;color:var(--ink);padding:8px 12px;border-radius:9px}
  .tab-head button.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
  .tab{display:none;margin-top:10px;border:1px solid var(--edge);border-radius:12px;padding:12px;background:#0e141a}
  .tab.active{display:block}
  textarea.out{width:100%;min-height:120px;background:#0b1117;color:#d8faff;border:1px solid #1b242e;border-radius:8px;padding:10px}
  .row .btn{padding:7px 12px;font-weight:600}
  .diag{margin-top:12px;border:1px dashed var(--edge);padding:10px;border-radius:10px;background:#0c1117}
  .note{color:var(--dim);font-size:.92rem}
  .hidden{display:none!important}

  .nsfw-gate{display:flex;gap:8px;align-items:center;margin:6px 0 12px 0}
  .nsfw-gate input{border:1px solid var(--edge);background:#0f141a;color:var(--ink);padding:6px 10px;border-radius:8px}
</style>
</head>
<body>
<div class="wrap">
  <h1>PF FaceMapper — Prompt Lab</h1>
  <div class="row">
    <input id="file" type="file" accept="image/*"/>
    <button id="demo" class="btn">Load Demo Face</button>
    <button id="toggleGuides" class="btn">Guides: OFF</button>
    <span id="status">status: <b>booting…</b></span>
  </div>

  <div class="stage">
    <div class="inner" id="stage">
      <canvas id="prev"></canvas>
      <canvas id="over"></canvas>
      <div class="mower"></div>
      <div class="legend">
        <span class="chip">face: <span id="faceRead">—</span></span>
        <span class="chip">shape: <span id="shapeRead">—</span></span>
        <span class="chip">eye°: <span id="eyeRead">—</span></span>
      </div>
    </div>
  </div>

  <div class="tabs">
    <div class="tab-head" role="tablist">
      <button class="active" data-tab="sfw" role="tab" aria-selected="true">SFW Prompt</button>
      <button data-tab="nsfw" role="tab">NSFW (locked)</button>
      <button data-tab="meas" role="tab">Measurements</button>
      <button data-tab="json" role="tab">JSON</button>
    </div>

    <div id="tab_sfw" class="tab active" role="tabpanel">
      <textarea id="outSFW" class="out" readonly></textarea>
      <div class="row">
        <button class="btn" id="copySFW" disabled>Copy SFW</button>
      </div>
    </div>

    <div id="tab_nsfw" class="tab" role="tabpanel">
      <div id="gate" class="nsfw-gate">
        <span class="note">Enter password to unlock NSFW (testing only):</span>
        <input id="pw" placeholder="password"/>
        <button id="unlock" class="btn">Unlock</button>
        <span id="gateState" class="note"></span>
      </div>
      <div id="nsfwBody" class="hidden">
        <textarea id="outNSFW" class="out" readonly></textarea>
        <div class="row">
          <button class="btn" id="copyNSFW" disabled>Copy NSFW</button>
        </div>
        <div class="note">NSFW overlay shows chest sample region (for heuristic measurements).</div>
      </div>
    </div>

    <div id="tab_meas" class="tab" role="tabpanel">
      <textarea id="outMeas" class="out" readonly></textarea>
    </div>

    <div id="tab_json" class="tab" role="tabpanel">
      <textarea id="outJson" class="out" readonly></textarea>
      <div class="row">
        <button class="btn" id="btnExport" disabled>Export JSON</button>
      </div>
    </div>
  </div>

  <div class="diag">
    <div class="kv">
      <div>Bundle:</div>  <div id="bundleState">…</div>
      <div>Model:</div>   <div id="modelState">…</div>
      <div>CDN tried:</div><div id="cdnTried">—</div>
      <div>User agent:</div><div><small id="ua"></small></div>
    </div>
    <div class="note" style="margin-top:8px">
      IMAGE-only lab. All analysis is on-device and heuristic; treat NSFW attributes as experimental with a confidence score.
    </div>
  </div>
</div>

<script type="module">
/* ---------------- Canvas & UI ---------------- */
const cPrev = document.getElementById('prev');
const cOver = document.getElementById('over');
const ctxPrev = cPrev.getContext('2d',{ willReadFrequently:true });
const ctxOver = cOver.getContext('2d');
const file = document.getElementById('file');
const demo = document.getElementById('demo');
const statusEl = document.getElementById('status');
const toggleGuides = document.getElementById('toggleGuides');
const faceRead = document.getElementById('faceRead');
const shapeRead = document.getElementById('shapeRead');
const eyeRead = document.getElementById('eyeRead');
const outSFW = document.getElementById('outSFW');
const outNSFW = document.getElementById('outNSFW');
const outMeas = document.getElementById('outMeas');
const outJson = document.getElementById('outJson');
const copySFW = document.getElementById('copySFW');
const copyNSFW = document.getElementById('copyNSFW');
const btnExport = document.getElementById('btnExport');
const bundleState = document.getElementById('bundleState');
const modelState = document.getElementById('modelState');
const cdnTried = document.getElementById('cdnTried');
document.getElementById('ua').textContent = navigator.userAgent;

function fit(){
  const r = document.getElementById('stage').getBoundingClientRect();
  const d = Math.min(devicePixelRatio||1,2);
  cPrev.width = cOver.width = Math.round(r.width * d);
  cPrev.height= cOver.height= Math.round(r.height* d);
  cPrev.style.width = cOver.style.width = r.width + 'px';
  cPrev.style.height= cOver.style.height= r.height+ 'px';
  ctxPrev.setTransform(d,0,0,d,0,0);
  ctxOver.setTransform(d,0,0,d,0,0);
}
addEventListener('resize', fit, {passive:true}); fit();

/* -------------- Multi-CDN fallback loader -------------- */
const CDN = {
  jsDelivr:{ esm:"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs",
             umd:"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.js",
             wasm:"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm" },
  unpkg:   { esm:"https://unpkg.com/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs",
             umd:"https://unpkg.com/@mediapipe/tasks-vision@0.10.14/vision_bundle.js",
             wasm:"https://unpkg.com/@mediapipe/tasks-vision@0.10.14/wasm" }
};
const MODEL_URL="https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task";

let FilesetResolver=null, FaceLandmarker=null, DrawingUtils=null, wasmRootUsed='';
async function tryESM(url){ bundleState.innerHTML=`trying ESM: <code>${url}</code>`; const m=await import(url); return {FilesetResolver:m.FilesetResolver,FaceLandmarker:m.FaceLandmarker,DrawingUtils:m.DrawingUtils}; }
function tryUMD(url){ bundleState.innerHTML=`trying UMD: <code>${url}</code>`; return new Promise((resolve,reject)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.crossOrigin="anonymous";
  s.onload=()=>{ const FL=globalThis.FaceLandmarker, FR=globalThis.FilesetResolver, DU=globalThis.DrawingUtils; if(FL&&FR&&DU) resolve({FilesetResolver:FR,FaceLandmarker:FL,DrawingUtils:DU}); else reject(new Error('UMD globals missing')); };
  s.onerror=()=>reject(new Error('UMD load error')); document.head.appendChild(s); }); }
async function loadBundle(){
  const order=[ {cdn:'jsDelivr',type:'ESM',fn:()=>tryESM(CDN.jsDelivr.esm),wasm:CDN.jsDelivr.wasm},
                {cdn:'unpkg',   type:'ESM',fn:()=>tryESM(CDN.unpkg.esm),   wasm:CDN.unpkg.wasm},
                {cdn:'jsDelivr',type:'UMD',fn:()=>tryUMD(CDN.jsDelivr.umd),wasm:CDN.jsDelivr.wasm},
                {cdn:'unpkg',   type:'UMD',fn:()=>tryUMD(CDN.unpkg.umd),   wasm:CDN.unpkg.wasm} ];
  const tried=[]; for(const step of order){ tried.push(`${step.cdn} ${step.type}`); cdnTried.textContent=tried.join(' → ');
    try{ const m=await step.fn(); FilesetResolver=m.FilesetResolver; FaceLandmarker=m.FaceLandmarker; DrawingUtils=m.DrawingUtils; wasmRootUsed=step.wasm; bundleState.innerHTML=`<span class="ok">Bundle OK</span> via <b>${step.cdn} ${step.type}</b>`; return true; }
    catch(e){ /* continue */ } }
  bundleState.innerHTML=`<span class="bad">Bundle blocked</span> — all CDNs failed`; return false;
}

/* -------------- Init model -------------- */
statusEl.innerHTML='status: <b>loading bundle…</b>';
const bundleOk = await loadBundle();
let face=null;
if(!bundleOk){ statusEl.innerHTML='status: <b class="bad">bundle blocked</b>'; }
else{
  statusEl.innerHTML='status: <b>loading model…</b>';
  try{
    const fs = await FilesetResolver.forVisionTasks(wasmRootUsed);
    face = await FaceLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:MODEL_URL}, runningMode:'IMAGE', numFaces:1 });
    modelState.innerHTML='<span class="ok">Model OK</span>';
    statusEl.innerHTML='status: <b class="ok">ready</b>';
  }catch(e){
    modelState.innerHTML='<span class="bad">Model blocked</span>';
    statusEl.innerHTML='status: <b class="bad">model blocked</b>';
  }
}

/* -------------- Helpers -------------- */
let showGuides=false;
toggleGuides.onclick=()=>{ showGuides=!showGuides; toggleGuides.textContent='Guides: '+(showGuides?'ON':'OFF'); if(lastLm) drawOverlay(lastLm,true); };

const indices={ faceH:[10,152], jawW:[234,454], cheekW:[234,454], foreheadH:[8,10], lipT:[13,14], eyeAngle:[133,362] };
const toDeg = r=>r*180/Math.PI;
function eyeAngleDeg(lm){ const a=indices.eyeAngle[0], b=indices.eyeAngle[1]; return toDeg(Math.atan2(lm[b].y-lm[a].y, lm[b].x-lm[a].x)); }
function dist(a,b,lm){ const dx=lm[a].x-lm[b].x, dy=lm[a].y-lm[b].y; return Math.hypot(dx,dy); }
function bbox(lm){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of lm){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function classify(jaw_face,cheek_face){ if(jaw_face<0.45 && cheek_face<0.55) return 'oval'; if(Math.abs(jaw_face-cheek_face)<0.03 && jaw_face>0.5) return 'round'; if(jaw_face>=0.55 && cheek_face>=0.6) return 'square'; if(cheek_face>jaw_face+0.07) return 'heart'; return 'triangle'; }
function hex(r,g,b){ return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
function avgRectRGBA(data,W,H,x,y,w,h,step=2){
  const x0=Math.max(0,Math.floor(x)), y0=Math.max(0,Math.floor(y)), x1=Math.min(W,Math.floor(x+w)), y1=Math.min(H,Math.floor(y+h));
  let r=0,g=0,b=0,c=0; for(let yy=y0;yy<y1;yy+=step){ for(let xx=x0;xx<x1;xx+=step){ const i=(yy*W+xx)*4; r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++; } }
  if(!c) return {hex:'#000000', mean:[0,0,0], count:0}; r=(r/c)|0; g=(g/c)|0; b=(b/c)|0; return {hex:hex(r,g,b), mean:[r,g,b], count:c};
}
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b); const d=max-min; let h=0; const s=max?d/max:0; const v=max;
  if(d!==0){ switch(max){ case r:h=(g-b)/d + (g<b?6:0); break; case g:h=(b-r)/d + 2; break; case b:h=(r-g)/d + 4; break; } h/=6; }
  return [h*360,s,v];
}

/* simple skin mask in YCbCr (very rough, for nudity heuristics) */
function rgb2ycbcr(r,g,b){ const y =  0.299*r + 0.587*g + 0.114*b;
  const cb= -0.168736*r - 0.331264*g + 0.5*b + 128;
  const cr=  0.5*r - 0.418688*g - 0.081312*b + 128;
  return [y,cb,cr];
}
function buildSkinMask(imgData,W,H){
  const m=new Uint8Array(W*H);
  const d=imgData.data;
  for(let i=0,p=0;i<d.length;i+=4,++p){
    const r=d[i], g=d[i+1], b=d[i+2];
    const [y,cb,cr]=rgb2ycbcr(r,g,b);
    const isSkin = (cb>77 && cb<127 && cr>133 && cr<173 && y>40);
    m[p]=isSkin?1:0;
  }
  return m;
}
function skinRatio(mask,W,H,x,y,w,h,step=2){
  const x0=Math.max(0,Math.floor(x)), y0=Math.max(0,Math.floor(y));
  const x1=Math.min(W,Math.floor(x+w)), y1=Math.min(H,Math.floor(y+h));
  let skin=0, tot=0;
  for(let yy=y0; yy<y1; yy+=step){ for(let xx=x0; xx<x1; xx+=step){ const p=yy*W+xx; skin+=mask[p]; tot++; } }
  return tot? skin/tot : 0;
}

/* candle-ish hotspot heuristic */
function warmHotspots(imgData,W,H){
  const d=imgData.data; let count=0;
  for(let y=0;y<H;y+=4){
    for(let x=0;x<W;x+=4){
      const i=(y*W+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
      const [h,s,v]=rgb2hsv(r,g,b);
      if(v>0.85 && s>0.3 && h>20 && h<55){ count++; }
    }
  }
  return count;
}

/* background guess (very rough) */
function backgroundTag(imgData,W,H){
  let gCnt=0, bCnt=0, wCnt=0, n=0; const d=imgData.data;
  for(let y=0;y<H;y+=10){ for(let x=0;x<W;x+=10){ const i=(y*W+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
    const [h,s,v]=rgb2hsv(r,g,b); n++;
    if(s>0.25 && v>0.15 && h>80 && h<160) gCnt++;
    if(s>0.2 && v>0.25 && (h<220&&h>190 || h<210&&h>170)) bCnt++; // bluish
    if(s<0.1 && v>0.9) wCnt++; // bright white lights
  }}
  const green=gCnt/n, blue=bCnt/n, white=wCnt/n;
  if(green>0.25) return 'forest/foliage';
  if(blue>0.25) return 'sky/water';
  if(white>0.10) return 'bright/indoor';
  return 'neutral';
}

/* hair sampling */
function hairSkinEyes(lm,W,H,imgData){
  const b=bbox(lm), x0=b.minX*W, y0=b.minY*H, x1=b.maxX*W, y1=b.maxY*H;
  const faceW=(x1-x0), faceH=(y1-y0);
  const hairBand = avgRectRGBA(imgData.data,W,H, x0, Math.max(0,y0-12), faceW, 10, 1);
  const skinMid  = avgRectRGBA(imgData.data,W,H, x0+0.35*faceW, y0+0.45*faceH, 18,18,1);
  const e = lm[133]; const eyes = avgRectRGBA(imgData.data,W,H, e.x*W-8, e.y*H-8, 16,16,1);
  return { hair:hairBand.hex, skin:skinMid.hex, eyes:eyes.hex };
}
function colorWord(hexHex){
  const [r,g,b]=[ parseInt(hexHex.slice(1,3),16), parseInt(hexHex.slice(3,5),16), parseInt(hexHex.slice(5,7),16) ];
  const [h,s,v]=rgb2hsv(r,g,b);
  if(v<0.15) return 'black';
  if(s<0.15) return v>0.8?'white':'light';
  if(h<15||h>345) return 'red';
  if(h<45) return 'blonde/golden';
  if(h<75) return 'blonde';
  if(h<150) return 'green';
  if(h<220) return 'blue';
  if(h<275) return 'purple';
  if(h<330) return 'magenta';
  return 'brown';
}

/* guides & overlay */
let lastLm=null, lastImg=null, chestRect=null, nsfwUnlocked=false;
function drawOverlay(lm, force=false){
  const W=cPrev.width/(devicePixelRatio||1), H=cPrev.height/(devicePixelRatio||1);
  ctxOver.clearRect(0,0,W,H);
  if(!lm) return;
  try{ new DrawingUtils(ctxOver).drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_TESSELLATION, { color:'rgba(100,242,227,.95)', lineWidth:.9 }); }catch{}
  const d=new DrawingUtils(ctxOver);
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE,     {color:'rgba(255,255,255,.95)',lineWidth:2});
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,      {color:'rgba(255,255,255,.95)',lineWidth:2});
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYEBROW, {color:'rgba(255,220,120,.95)',lineWidth:2});
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LEFT_EYEBROW,  {color:'rgba(255,220,120,.95)',lineWidth:2});
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LIPS,          {color:'rgba(255,120,160,.95)',lineWidth:2});
  d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,     {color:'rgba(140,255,220,.95)',lineWidth:2});

  if((showGuides||nsfwUnlocked) && chestRect){
    ctxOver.save();
    ctxOver.strokeStyle='rgba(255,120,160,.85)';
    ctxOver.setLineDash([6,5]); ctxOver.lineWidth=2;
    ctxOver.strokeRect(chestRect.x, chestRect.y, chestRect.w, chestRect.h);
    ctxOver.restore();
  }
}

/* -------------- Main: run on image -------------- */
async function runOnImage(img){
  if(!face){ statusEl.innerHTML='status: <b class="bad">no model</b>'; return; }
  const W = cPrev.width/(devicePixelRatio||1), H = cPrev.height/(devicePixelRatio||1);
  ctxPrev.clearRect(0,0,W,H);
  const r = Math.min(W/img.width, H/img.height);
  const dw = img.width*r, dh = img.height*r, dx=(W-dw)/2, dy=(H-dh)/2;
  ctxPrev.drawImage(img, dx, dy, dw, dh);
  lastImg={W,H,dx,dy,dw,dh};

  statusEl.innerHTML='status: <b>detecting…</b>';
  let res; try{ res=await face.detect(img); }catch(e){ statusEl.innerHTML='status: <b class="bad">detect error</b>'; console.error(e); return; }
  const lm = res?.faceLandmarks && res.faceLandmarks[0];
  if(!lm){ statusEl.innerHTML='status: <b class="warn">no face</b>'; return; }

  // normalize to canvas pixels
  const lmPx = lm.map(p=>({x:dx+p.x*dw, y:dy+p.y*dh, z:p.z}));
  lastLm=lmPx;

  // measures (in px on canvas)
  const faceHpx = dist(10,152,lmPx);
  const jawWpx  = dist(234,454,lmPx);
  const cheekWpx= dist(234,454,lmPx);
  const foreHpx = dist(8,10,lmPx);
  const lipTpx  = dist(13,14,lmPx);
  const eyeDeg  = +eyeAngleDeg(lmPx).toFixed(2);

  const ratios = {
    jaw_face: +(jawWpx/faceHpx).toFixed(3),
    cheek_face:+(cheekWpx/faceHpx).toFixed(3),
    forehead_face:+(foreHpx/faceHpx).toFixed(3),
    lip_face:+(lipTpx/faceHpx).toFixed(3)
  };
  const shape = classify(ratios.jaw_face, ratios.cheek_face);

  // basic reads
  faceRead.textContent = `${faceHpx.toFixed(1)}px H`;
  shapeRead.textContent= shape;
  eyeRead.textContent  = `${eyeDeg}°`;

  // image pixels & palettes
  const imgData = ctxPrev.getImageData(0,0,W,H);
  const pal = hairSkinEyes(lmPx,W,H,imgData);
  const hairWord = colorWord(pal.hair);
  const bgTag = backgroundTag(imgData,W,H);
  const hotspots = warmHotspots(imgData,W,H);

  // SFW prompt
  const sfw = [
    `portrait photo, ${shape} face`,
    `hair: ${hairWord}`, 
    `skin ${pal.skin}, eyes ${pal.eyes}`,
    bgTag!=='neutral'? `${bgTag} background` : `natural background`,
    `eye angle ${eyeDeg}°`,
    `neutral lighting, photorealistic`
  ].join(', ');
  outSFW.value = sfw;
  copySFW.disabled=false;

  // NSFW heuristics (chest box relative to face bbox)
  const b = bbox(lmPx), x0=b.minX, y0=b.minY, x1=b.maxX, y1=b.maxY;
  const fW=(x1-x0), fH=(y1-y0);
  const cx = (x0+x1)/2;
  chestRect = { x: cx - 0.68*fW, y: y1 + 0.12*fH, w: 1.36*fW, h: 1.10*fH };
  // clamp to canvas
  chestRect.x = Math.max(0, chestRect.x);
  chestRect.y = Math.max(0, chestRect.y);
  if(chestRect.x+chestRect.w>W) chestRect.w = W-chestRect.x;
  if(chestRect.y+chestRect.h>H) chestRect.h = H-chestRect.y;

  // skin mask + ratios
  const skinMask = buildSkinMask(imgData,W,H);
  const chestSkin = skinRatio(skinMask,W,H, chestRect.x,chestRect.y,chestRect.w,chestRect.h,2); // ~0..1

  // crude nipple candidates: look for warm/darkish spots inside chest rect
  const d = imgData.data; let candidates=[];
  for(let yy=Math.floor(chestRect.y); yy<Math.floor(chestRect.y+chestRect.h); yy+=4){
    for(let xx=Math.floor(chestRect.x); xx<Math.floor(chestRect.x+chestRect.w); xx+=4){
      const i=(yy*W+xx)*4; const r=d[i], g=d[i+1], b=d[i+2]; const [h,s,v]=rgb2hsv(r,g,b);
      if(skinMask[yy*W+xx] && v>0.18 && v<0.85 && s>0.25 && (h>5 && h<40)){ // warm-ish
        // redness score
        const score = s*(0.9-v);
        candidates.push({x:xx,y:yy,score});
      }
    }
  }
  candidates.sort((a,b)=>b.score-a.score);
  // pick two far apart horizontally
  let nipA=null,nipB=null;
  const minSep = chestRect.w*0.25;
  for(const c of candidates){
    if(!nipA){ nipA=c; continue; }
    const dx=Math.abs(c.x-nipA.x), dy=Math.abs(c.y-nipA.y);
    if(dx>minSep && dy<chestRect.h*0.25){ nipB=c; break; }
  }
  const nipplesVisible = !!(nipA && nipB);
  const nippleConfidence = nipplesVisible ? Math.min(0.95, (candidates[0]?.score + candidates[1]?.score)/1.6) : 0;

  // breast size guess from chest width vs face height + skin ratio
  const chestW_to_faceH = (chestRect.w / faceHpx);
  let breastSize='unknown';
  if(chestSkin>0.55){ // likely exposed chest
    if(chestW_to_faceH<1.55) breastSize='small';
    else if(chestW_to_faceH<2.05) breastSize='medium';
    else breastSize='large';
  }

  // pubic/underarm hair: too hard reliably → derive from texture variance if lower frame has skin patches (very noisy)
  // For now: mark as "unknown" unless skin ratio below chest suggests clothing/bikini (then "not visible")
  let bodyHair='unknown'; // placeholder; we’ll refine with pose later

  // background candle-ish?
  const candleLikely = hotspots>40; // arbitrary threshold for many warm hotspots
  const lighting = candleLikely ? 'warm candlelight' : (bgTag==='bright/indoor'?'bright indoor':'natural light');

  // NSFW prompt (only set text; actual viewing gated below)
  const nsfwParts = [
    `nude ${hairWord} woman`,
    `pale/skin ${pal.skin}, ${shape} face`,
    breastSize!=='unknown' ? `${breastSize} natural breasts` : `natural breasts`,
    nipplesVisible?`visible nipples`:``,
    `long straight hair`,
    `${bgTag} background`,
    `${lighting}`,
    `photorealistic`
  ].filter(Boolean);
  const nsfwPrompt = nsfwParts.join(', ');
  outNSFW.value = nsfwPrompt;

  // measurements & JSON
  const measures = {
    face_height:+faceHpx.toFixed(3), jaw_width:+jawWpx.toFixed(3), cheek_width:+cheekWpx.toFixed(3),
    forehead_height:+foreHpx.toFixed(3), lip_thickness:+lipTpx.toFixed(3), eye_angle_deg:eyeDeg
  };
  outMeas.value = [
    `faceH: ${measures.face_height}px`,
    `jawW: ${measures.jaw_width}px`,
    `cheekW: ${measures.cheek_width}px`,
    `foreheadH: ${measures.forehead_height}px`,
    `lipT: ${measures.lip_thickness}px`,
    `eyeDeg: ${measures.eye_angle_deg}°`,
    `ratios: jaw/face ${ratios.jaw_face}, cheek/face ${ratios.cheek_face}, forehead/face ${ratios.forehead_face}, lip/face ${ratios.lip_face}`,
    `palette: hair ${pal.hair} (${hairWord}), skin ${pal.skin}, eyes ${pal.eyes}`,
    `background: ${bgTag}, hotspots(candle-ish): ${hotspots}`
  ].join('\n');

  const schema={
    version:"pf_facemapper_3",
    indices,
    frame:{type:"image"},
    image:{width:img.width, height:img.height},
    measures_px:measures,
    ratios,
    shape,
    palette_hex:pal,
    landmarks_norm: lm.map(p=>[ +((p.x-dx)/dw).toFixed(6), +((p.y-dy)/dh).toFixed(6), +(p.z??0).toFixed(6) ]),
    nsfw_inference:{
      chest_rect_canvas:{x:+chestRect.x.toFixed(2),y:+chestRect.y.toFixed(2),w:+chestRect.w.toFixed(2),h:+chestRect.h.toFixed(2)},
      chest_skin_ratio:+chestSkin.toFixed(3),
      nipples_visible:nipplesVisible,
      nipple_confidence:+nippleConfidence.toFixed(3),
      breast_size:breastSize,
      body_hair:bodyHair,
      lighting, background_tag:bgTag, hotspots
    }
  };
  outJson.value = JSON.stringify(schema,null,2);
  btnExport.disabled=false;

  drawOverlay(lmPx,true);
}

/* -------------- File + demo -------------- */
file.addEventListener('change', ()=>{
  const f=file.files && file.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image();
  img.onload = ()=>{ runOnImage(img); URL.revokeObjectURL(url); };
  img.onerror= ()=>{ statusEl.innerHTML='status: <b class="bad">image load failed</b>'; URL.revokeObjectURL(url); };
  img.src=url;
});
// same tiny demo PNG used before
const demoPng="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANAAAADQCAYAAAD3QmL4AAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVR4nO3TwQmDQBQF0eT9T2iZgQq3Zy7y1qkH1bYw+5h4v5yKp1lGgAAAAAAAAAAAAAAAPzXr8nqGk9i2y3bG2wqk9gRz8yVwz5w7k1m0t0b3m4v0bq9wq3g5w4e3Qv6wz7P3vTgPpJkAAJ4w0n8C3q7v9v0FJr7nYt9b3x2cW3O2mXxg7iB9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ+eGgAA+S9cFf7r+f3bJrS6cV7fNw9u8s7xw7v+f2C6v7p/8eZ7c4+f3b8v7n+DDkAAE9h8gMAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAoB1B/0iJ7o9J0c9AAAAAElFTkSuQmCC";
demo.addEventListener('click', ()=>{ const img=new Image(); img.onload=()=>runOnImage(img); img.onerror=()=>statusEl.innerHTML='status: <b class="bad">demo image failed</b>'; img.src=demoPng; });

/* -------------- Tabs + copy + export -------------- */
document.querySelectorAll('.tab-head button').forEach(b=>b.addEventListener('click',()=>{
  document.querySelectorAll('.tab-head button').forEach(x=>x.classList.remove('active')); b.classList.add('active');
  document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
  document.getElementById('tab_'+b.dataset.tab).classList.add('active');
}));
function copyText(el){ navigator.clipboard.writeText(el.value||'').catch(()=>{}); }
copySFW.onclick=()=>copyText(outSFW);
copyNSFW.onclick=()=>copyText(outNSFW);
btnExport.onclick=()=>{ const blob=new Blob([outJson.value],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='face_prompt_lab.json'; document.body.appendChild(a); a.click(); setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);},200); };

/* -------------- NSFW lock -------------- */
const pw=document.getElementById('pw'), unlock=document.getElementById('unlock'), gate=document.getElementById('gate'), gateState=document.getElementById('gateState'), nsfwBody=document.getElementById('nsfwBody');
unlock.onclick=()=>{ if((pw.value||'').trim().toLowerCase()==='forge'){ nsfwUnlocked=true; gate.classList.add('hidden'); nsfwBody.classList.remove('hidden'); copyNSFW.disabled=false; gateState.textContent=''; drawOverlay(lastLm,true); } else { gateState.textContent='wrong password'; } };
pw.addEventListener('keydown',e=>{ if(e.key==='Enter') unlock.click(); });

</script>
</body>
</html>
