<!-- imageintel.html — ImageIntel Pro Lab (SAFE: Objects + Pose + Face + Body Mesh + Silhouette + Prompt) -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ImageIntel Pro Lab — BlackSite HUD</title>
<meta name="color-scheme" content="dark"/>
<style>
:root{--bg:#070a0f;--grid:rgba(255,255,255,.04);--panel:#0d121a;--muted:#94a3b8;--text:#e6f1ff;--chip:#101826;--radius:18px}
*{box-sizing:border-box}html,body{height:100%}body{margin:0;background:radial-gradient(1200px 1200px at 10% -10%,#0c1420,var(--bg)) fixed;color:var(--text);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
body::before{content:"";position:fixed;inset:0;pointer-events:none;z-index:0;background-image:linear-gradient(var(--grid) 1px,transparent 1px),linear-gradient(90deg,var(--grid) 1px,transparent 1px);background-size:28px 28px;mask-image:radial-gradient(1000px 700px at 10% 0%,#000 80%,transparent)}
.app{position:relative;z-index:1;height:100%;display:grid;gap:12px;padding:12px;grid-template-columns:1.3fr .7fr;grid-template-rows:68% 32%;grid-template-areas:"stage side" "kpi side"}
.card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.005));border:1px solid rgba(255,255,255,.08);border-radius:18px;backdrop-filter:blur(6px)}
.title{font-weight:700;letter-spacing:.08em;text-transform:uppercase;font-size:11px;color:var(--muted)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}.col{display:grid;gap:8px}
.chip{background:var(--chip);border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 10px;font-size:12px;color:#b6cdfb}
.btn{background:linear-gradient(180deg,rgba(62,248,255,.15),rgba(62,248,255,.06));border:1px solid rgba(62,248,255,.45);color:#cfffff;padding:8px 12px;border-radius:10px;cursor:pointer}
.btn.secondary{border-color:rgba(102,255,153,.45);background:linear-gradient(180deg,rgba(102,255,153,.16),rgba(102,255,153,.06));color:#dbffe8}
.btn.warn{border-color:rgba(255,209,102,.45);background:linear-gradient(180deg,rgba(255,209,102,.16),rgba(255,209,102,.06));color:#fff3cf}
.btn.ghost{background:transparent;border:1px dashed rgba(255,255,255,.25)}
.toggle{display:inline-flex;align-items:center;gap:6px;cursor:pointer}
.toggle input{appearance:none;width:30px;height:18px;border-radius:999px;background:#15202f;border:1px solid rgba(255,255,255,.2);position:relative}
.toggle input:checked{background:#0e2c2c;border-color:rgba(62,248,255,.5)}
.toggle input::after{content:"";position:absolute;top:1px;left:1px;width:14px;height:14px;background:#9aa7bd;border-radius:50%;transition:160ms}
.toggle input:checked::after{left:calc(100% - 15px);background:#72ffd5}
#stage{grid-area:stage;display:grid;grid-template-rows:auto 1fr auto;overflow:hidden}
.stage-head{padding:10px;display:flex;align-items:center;justify-content:space-between}
.canvas-wrap{position:relative;overflow:hidden;background:#0b0f14;border-top:1px solid rgba(255,255,255,.06);border-bottom:1px solid rgba(255,255,255,.06)}
#inputImage{max-width:100%;max-height:100%;display:block}
#overlay{position:absolute;left:0;top:0;image-rendering:pixelated}
#kpis{grid-area:kpi;display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:10px;overflow:auto}
.kpi{background:#0d121a;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px;min-height:120px;display:grid;grid-template-rows:auto 1fr}
.list{display:grid;gap:6px;font-size:12px}.pill{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);display:flex;justify-content:space-between}
#side{grid-area:side;display:grid;grid-template-rows:auto auto 1fr auto}
#terminal{height:200px;overflow:auto;background:#05070b;border-top:1px solid rgba(255,255,255,.08);padding:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#b0c3e6}
.log.ok{color:#5cff7a}.log.err{color:#ff4d6d}
.statusbar{display:flex;gap:6px;flex-wrap:wrap}.statusbar .chip.ok{border-color:rgba(102,255,153,.45);color:#d5ffe5}.statusbar .chip.err{border-color:rgba(255,77,109,.45);color:#ffd0da}
textarea#promptOut{width:100%;resize:vertical;background:#05070b;color:#e6f1ff;border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px}
pre#diagDump{max-height:200px;overflow:auto;background:#03050a;border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px;color:#cfe1ff}
</style>
</head>
<body>
<div class="app">
  <section id="stage" class="card">
    <div class="stage-head">
      <div class="row">
        <span class="title">BLACKSITE HUD</span>
        <span class="chip">Objects</span><span class="chip">Pose</span><span class="chip">Face</span><span class="chip">Body Mesh</span><span class="chip">Silhouette</span>
        <span class="chip" id="fpsChip">FPS — n/a</span>
      </div>
      <div class="row">
        <button id="demoBtn" class="btn">Load Demo</button>
        <label class="btn ghost" for="file">Upload Image</label>
        <input id="file" type="file" accept="image/*" style="display:none"/>
        <button id="runBtn" class="btn secondary" disabled>Run Analysis</button>
      </div>
    </div>
    <div class="canvas-wrap" id="canvasWrap">
      <img id="inputImage" crossorigin="anonymous" alt="input"/>
      <canvas id="overlay"></canvas>
    </div>
    <div class="panel-body" style="display:grid;grid-template-columns:1fr auto;align-items:center;padding:10px;">
      <div class="statusbar" id="statusbar">
        <span class="chip" id="st-hosting">Hosting OK</span>
        <span class="chip" id="st-wasm">WASM — …</span>
        <span class="chip" id="st-obj">Object Model — …</span>
        <span class="chip" id="st-pose">Pose Model — …</span>
        <span class="chip" id="st-face">Face Model — …</span>
        <span class="chip" id="st-image">Image — …</span>
        <span class="chip" id="st-run">Detectors — …</span>
      </div>
      <div class="row">
        <span class="title">Snapshot & Export</span>
        <button id="exportPng" class="btn">PNG</button>
        <button id="exportJson" class="btn">JSON</button>
      </div>
    </div>
  </section>

  <section id="kpis" class="card">
    <div class="kpi"><h4 class="title">Subject</h4><div class="list" id="subjectList"></div></div>
    <div class="kpi"><h4 class="title">Objects</h4><div class="list" id="objectList"></div></div>
    <div class="kpi"><h4 class="title">Pose</h4><div class="list" id="poseList"></div></div>
    <div class="kpi"><h4 class="title">Color / Lighting</h4><div class="list" id="colorList"></div></div>
  </section>

  <aside id="side" class="card">
    <div class="panel-head" style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.08)">
      <span class="title">Controls</span>
      <div class="row">
        <label class="toggle"><input id="tgObjects" type="checkbox" checked><span>Objects</span></label>
        <label class="toggle"><input id="tgPose" type="checkbox" checked><span>Pose</span></label>
        <label class="toggle"><input id="tgFace" type="checkbox" checked><span>Face</span></label>
        <label class="toggle"><input id="tgBody" type="checkbox" checked><span>Body Mesh</span></label>
        <label class="toggle"><input id="tgSil" type="checkbox" checked><span>Silhouette</span></label>
        <label class="toggle" title="Force CPU delegates"><input id="safeMode" type="checkbox"><span>Safe Mode</span></label>
      </div>
    </div>

    <div id="controls" class="panel-body">
      <div class="row">
        <div class="col" style="min-width:160px"><label>Objects Opacity</label><input id="opObjects" type="range" min="0" max="1" step="0.05" value="0.9"/></div>
        <div class="col" style="min-width:160px"><label>Pose Opacity</label><input id="opPose" type="range" min="0" max="1" step="0.05" value="0.9"/></div>
        <div class="col" style="min-width:160px"><label>Face Opacity</label><input id="opFace" type="range" min="0" max="1" step="0.05" value="0.9"/></div>
        <div class="col" style="min-width:160px"><label>Body Mesh Opacity</label><input id="opBody" type="range" min="0" max="1" step="0.05" value="0.8"/></div>
        <div class="col" style="min-width:160px"><label>Silhouette Opacity</label><input id="opSil" type="range" min="0" max="1" step="0.05" value="0.35"/></div>
      </div>
      <div class="row">
        <div class="col" style="min-width:200px;">
          <label>Prompt Mode</label>
          <select id="mode">
            <option value="sfw">SFW</option>
            <option value="nsfw_safe">NSFW-safe (redacted)</option>
            <option value="edgy">Edgy</option>
            <option value="poetic">Poetic</option>
            <option value="numeric">Numeric</option>
            <option value="json">Raw JSON</option>
          </select>
        </div>
        <div class="col" style="min-width:220px;"><label>Detail</label><input id="detail" type="range" min="0" max="100" step="1" value="70"/></div>
        <div class="col" style="min-width:280px;">
          <label>Prompt Sources</label>
          <div class="row">
            <label class="toggle"><input id="infObjects" type="checkbox" checked><span>Objects</span></label>
            <label class="toggle"><input id="infPose" type="checkbox" checked><span>Pose</span></label>
            <label class="toggle"><input id="infFace" type="checkbox" checked><span>Face</span></label>
            <label class="toggle"><input id="infColor" type="checkbox" checked><span>Colors/Light</span></label>
          </div>
        </div>
      </div>
      <div class="row">
        <button id="copyPrompt" class="btn">Copy Prompt</button>
        <button id="downloadPrompt" class="btn">Download .txt</button>
        <button id="overlayTest" class="btn ghost">Overlay Test</button>
        <button id="reinit" class="btn warn">Re-Init Models</button>
        <button id="selfTest" class="btn">Self-Test</button>
        <button id="copyDiag" class="btn">Copy Diag</button>
      </div>
      <pre id="diagDump" class="slab" aria-label="Diagnostics Output"></pre>
      <div class="row"><span class="title">NSFW Gate</span><span class="chip" id="nsfwGate">Disabled</span></div>
    </div>

    <div class="panel-head" style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-top:1px solid rgba(255,255,255,.08)">
      <span class="title">Prompt Output</span><span class="chip" id="promptChars">0 chars</span>
    </div>
    <div class="panel-body"><textarea id="promptOut" rows="6"></textarea></div>

    <div class="panel-head" style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-top:1px solid rgba(255,255,255,.08)">
      <span class="title">Diagnostics</span><span class="chip">Live Terminal</span>
    </div>
    <div id="terminal"></div>

    <div id="footer" style="display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px;border-top:1px solid rgba(255,255,255,.08)">
      <div class="row"><span class="title">Export</span><button id="exportOverlays" class="btn">Overlays .png</button></div>
      <div class="row"><span class="title">Ads Hook</span><span class="chip">placeholder</span></div>
    </div>
  </aside>
</div>

<script type="module">
/* Robust loader with CDN fallback. */
const CANDIDATES=[
  'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/vision_bundle.mjs',
  'https://unpkg.com/@mediapipe/tasks-vision@0.10.21/vision_bundle.mjs',
  'https://ga.jspm.io/npm:@mediapipe/tasks-vision@0.10.21/vision_bundle.mjs'
];
let vision, loadErr=[];
for(const url of CANDIDATES){ try{ vision=await import(url); console.log('[tasks-vision] loaded',url); break; }catch(e){ loadErr.push(`${url} → ${e?.message||e}`);} }
if(!vision){ document.body.insertAdjacentHTML('afterbegin', `<div style="padding:10px" class="card"><div class="fatal">FATAL: tasks-vision failed.<br>${loadErr.join('<br>')}</div></div>`); throw new Error('No tasks-vision'); }
const { FilesetResolver, ObjectDetector, PoseLandmarker, FaceLandmarker } = vision;

/* DOM refs */
const $=id=>document.getElementById(id);
const logEl=$('terminal'); const diag=$('diagDump'); const fpsChip=$('fpsChip');
const img=$('inputImage'), wrap=$('canvasWrap'), canvas=$('overlay'), ctx=canvas.getContext('2d');
const status={wasm:$('st-wasm'),obj:$('st-obj'),pose:$('st-pose'),face:$('st-face'),image:$('st-image'),run:$('st-run')};
const demoBtn=$('demoBtn'), fileInput=$('file'), runBtn=$('runBtn');
const tgObjects=$('tgObjects'), tgPose=$('tgPose'), tgFace=$('tgFace'), tgBody=$('tgBody'), tgSil=$('tgSil');
const opObjects=$('opObjects'), opPose=$('opPose'), opFace=$('opFace'), opBody=$('opBody'), opSil=$('opSil');
const objectList=$('objectList'), subjectList=$('subjectList'), poseList=$('poseList'), colorList=$('colorList');
const modeSel=$('mode'), detailRange=$('detail'), promptOut=$('promptOut'), promptChars=$('promptChars');
const copyPrompt=$('copyPrompt'), downloadPrompt=$('downloadPrompt'), exportOverlays=$('exportOverlays');
const overlayTestBtn=$('overlayTest'), reinitBtn=$('reinit'), selfTestBtn=$('selfTest'), copyDiagBtn=$('copyDiag'), nsfwGateEl=$('nsfwGate');
const cfg={ WASM:'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/wasm',
  OBJ:'https://storage.googleapis.com/mediapipe-tasks/object_detector/efficientdet_lite0_uint8.tflite',
  POSE:'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
  FACE:'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
  DEMO:'https://upload.wikimedia.org/wikipedia/commons/3/39/Tree_Woman.jpg'
};

/* State */
let visionWasm, detector, poser, facer, lastRun={}, safeMode=false, fps={t0:0,frames:0};

/* Utils */
const log=(m,ok)=>{ const d=document.createElement('div'); d.textContent=m; d.className='log'+(ok===true?' ok':ok===false?' err':''); logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; };
const setChip=(el,ok,okL='OK',errL='ERR')=>{ el.textContent=ok?okL:errL; el.classList.toggle('ok',!!ok); el.classList.toggle('err',!ok); };
function resize(){ if(!img.naturalWidth) return; const r=wrap.getBoundingClientRect(); const ia=img.naturalWidth/img.naturalHeight, ra=r.width/r.height; let w,h; if(ia>ra){w=r.width;h=w/ia;} else {h=r.height;w=h*ia;} canvas.width=w|0; canvas.height=h|0; img.style.width=w+'px'; img.style.height=h+'px'; }
const toHex=v=>Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0');

/* Pose indices/edges & body mesh triangles */
const LM={ NOSE:0, L_SH:11, R_SH:12, L_HIP:23, R_HIP:24, L_ELB:13, R_ELB:14, L_WR:15, R_WR:16, L_KNEE:25, R_KNEE:26, L_ANK:27, R_ANK:28 };
const EDGES=[[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[25,27],[24,26],[26,28],[27,31],[28,32]];
const TRI=[ [LM.L_SH,LM.R_SH,LM.L_HIP],[LM.R_SH,LM.R_HIP,LM.L_HIP],[LM.L_SH,LM.L_ELB,LM.L_HIP],[LM.R_SH,LM.R_ELB,LM.R_HIP],[LM.L_ELB,LM.L_WR,LM.L_HIP],[LM.R_ELB,LM.R_WR,LM.R_HIP],[LM.L_HIP,LM.R_HIP,LM.L_KNEE],[LM.R_HIP,LM.R_KNEE,LM.L_KNEE],[LM.L_KNEE,LM.L_ANK,LM.R_KNEE],[LM.R_KNEE,LM.R_ANK,LM.L_ANK] ];
const FACE_LM={ LEFT_EYE_TOP:159, LEFT_EYE_BOTTOM:145, RIGHT_EYE_TOP:386, RIGHT_EYE_BOTTOM:374, LEFT_EYE_IN:133, LEFT_EYE_OUT:33, RIGHT_EYE_IN:362, RIGHT_EYE_OUT:263, LEFT_IRIS_C:468, RIGHT_IRIS_C:473 };
const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y), rad2deg=r=>r*180/Math.PI, angle=(p,q)=>rad2deg(Math.atan2(q.y-p.y,q.x-p.x));

/* Drawing */
function scaleBox(b){ const sx=canvas.width/img.naturalWidth, sy=canvas.height/img.naturalHeight; return {x:b.originX*sx,y:b.originY*sy,w:b.width*sx,h:b.height*sy}; }
function drawObjects(res,a){ if(!res) return; ctx.save(); ctx.globalAlpha=a; ctx.lineWidth=2; ctx.font='12px ui-sans-serif';
  res.detections.forEach(d=>{ const {x,y,w,h}=scaleBox(d.boundingBox); ctx.strokeStyle='rgba(62,248,255,.9)'; ctx.shadowColor='rgba(62,248,255,.45)'; ctx.shadowBlur=8; ctx.strokeRect(x,y,w,h);
    const name=d.categories?.[0]?.categoryName||'object', s=d.categories?.[0]?.score||0, lab=`${name} ${(s*100).toFixed(0)}%`;
    const tw=ctx.measureText(lab).width+12, th=18; ctx.fillStyle='rgba(15,27,38,.9)'; ctx.fillRect(x,Math.max(0,y-th),tw,th);
    ctx.strokeStyle='rgba(62,248,255,.45)'; ctx.strokeRect(x,Math.max(0,y-th),tw,th); ctx.fillStyle='#c7faff'; ctx.fillText(lab,x+6,Math.max(0,y-th)+13); });
  ctx.restore(); }
function drawPose(res,a){ if(!res?.landmarks?.length) return; const l=res.landmarks[0]; ctx.save(); ctx.globalAlpha=a; ctx.lineWidth=3; ctx.strokeStyle='rgba(102,255,153,.95)'; ctx.shadowColor='rgba(102,255,153,.55)'; ctx.shadowBlur=10;
  EDGES.forEach(([i,j])=>{ const p=l[i], q=l[j]; if(!p||!q) return; ctx.beginPath(); ctx.moveTo(p.x*canvas.width,p.y*canvas.height); ctx.lineTo(q.x*canvas.width,q.y*canvas.height); ctx.stroke(); });
  ctx.fillStyle='rgba(102,255,153,.95)'; [LM.L_SH,LM.R_SH,LM.L_HIP,LM.R_HIP,LM.NOSE].forEach(k=>{const p=l[k]; if(!p) return; ctx.beginPath(); ctx.arc(p.x*canvas.width,p.y*canvas.height,4,0,6.283); ctx.fill();});
  ctx.restore(); }
function drawFace(res,a){ if(!res?.faceLandmarks?.length) return; const l=res.faceLandmarks[0]; ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='rgba(140,200,255,.9)'; ctx.shadowColor='rgba(140,200,255,.6)'; ctx.shadowBlur=8;
  for(let i=0;i<l.length;i+=2){ const p=l[i]; ctx.beginPath(); ctx.arc(p.x*canvas.width,p.y*canvas.height,1.4,0,6.283); ctx.fill(); }
  const out=[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109,10];
  ctx.strokeStyle='rgba(140,200,255,.6)'; ctx.lineWidth=1; ctx.beginPath(); out.forEach((i,ix)=>{ const p=l[i]; const x=p.x*canvas.width,y=p.y*canvas.height; if(ix===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke(); ctx.restore(); }
function drawBodyMesh(pose,a){ if(!pose?.landmarks?.length) return; const l=pose.landmarks[0]; ctx.save(); ctx.globalAlpha=a; ctx.lineWidth=1.5;
  TRI.forEach(([a1,b1,c1])=>{ const A=l[a1],B=l[b1],C=l[c1]; if(!A||!B||!C) return; ctx.beginPath(); ctx.moveTo(A.x*canvas.width,A.y*canvas.height); ctx.lineTo(B.x*canvas.width,B.y*canvas.height); ctx.lineTo(C.x*canvas.width,C.y*canvas.height); ctx.closePath(); ctx.strokeStyle='rgba(180,255,220,.8)'; ctx.stroke(); });
  ctx.restore(); }
function convexHull(points){ const pts=points.map(p=>({x:p.x*canvas.width,y:p.y*canvas.height})).filter(p=>Number.isFinite(p.x)&&Number.isFinite(p.y)); if(pts.length<3) return [];
  pts.sort((a,b)=>a.x===b.x?a.y-b.y:a.x-b.x); const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x); const lower=[],upper=[];
  for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  for(let i=pts.length-1;i>=0;--i){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop(); return lower.concat(upper); }
function drawSilhouette(pose,a){ if(!pose?.landmarks?.length) return {area:0,bbox:null,height:0};
  const l=pose.landmarks[0]; const use=[LM.L_SH,LM.R_SH,LM.L_ELB,LM.R_ELB,LM.L_WR,LM.R_WR,LM.L_HIP,LM.R_HIP,LM.L_KNEE,LM.R_KNEE,LM.L_ANK,LM.R_ANK,LM.NOSE].map(i=>l[i]).filter(Boolean);
  const hull=convexHull(use); if(!hull.length) return {area:0,bbox:null,height:0};
  ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='rgba(80,200,255,.18)'; ctx.strokeStyle='rgba(80,200,255,.55)'; ctx.lineWidth=2; ctx.beginPath(); hull.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; hull.forEach(p=>{minX=Math.min(minX,p.x);minY=Math.min(minY,p.y);maxX=Math.max(maxX,p.x);maxY=Math.max(maxY,p.y);});
  const bbox={x:minX,y:minY,w:maxX-minX,h:maxY-minY}; const area=bbox.w*bbox.h/(canvas.width*canvas.height); return {area,bbox,height:bbox.h}; }

/* Analysis */
function eulerFromM4(m){ const r00=m[0],r10=m[1],r20=m[2],r01=m[4],r11=m[5],r21=m[6],r02=m[8],r12=m[9],r22=m[10]; const sy=Math.hypot(r00,r10); let x,y,z; if(sy>1e-6){x=Math.atan2(r21,r22);y=Math.atan2(-r20,sy);z=Math.atan2(r10,r00);} else {x=Math.atan2(-r12,r11);y=Math.atan2(-r20,sy);z=0;} return {pitch:rad2deg(x),yaw:rad2deg(y),roll:rad2deg(z)}; }
function eyeOpen(l){ const L=(dist(l[FACE_LM.LEFT_EYE_TOP],l[FACE_LM.LEFT_EYE_BOTTOM])/dist(l[FACE_LM.LEFT_EYE_IN],l[FACE_LM.LEFT_EYE_OUT])), R=(dist(l[FACE_LM.RIGHT_EYE_TOP],l[FACE_LM.RIGHT_EYE_BOTTOM])/dist(l[FACE_LM.RIGHT_EYE_IN],l[FACE_LM.RIGHT_EYE_OUT])); const a=(L+R)/2; return a>0.22?'open':a<0.12?'closed':'narrow'; }
function gaze(l){ const lc=l[FACE_LM.LEFT_IRIS_C], rc=l[FACE_LM.RIGHT_IRIS_C]; if(!lc||!rc) return 'unknown'; const lr=(lc.x-l[33].x)/(l[133].x-l[33].x), rr=(rc.x-l[362].x)/(l[263].x-l[362].x), a=(lr+rr)/2; return a<0.35?'looking left':a>0.65?'looking right':'looking center'; }
function subjectSummary(pose,face){ const base={view:'unknown',eyes:'unknown',gaze:'unknown',roll:null,pitch:null,yaw:null};
  if(pose?.landmarks?.length){ const l=pose.landmarks[0], L=l[LM.L_SH], R=l[LM.R_SH], LH=l[LM.L_HIP], RH=l[LM.R_HIP]; if(L&&R&&LH&&RH){ base.shoulders_deg=Math.abs(angle(L,R)).toFixed(1); base.hips_deg=Math.abs(angle(LH,RH)).toFixed(1); const dz=Math.abs((L.z||0)-(R.z||0)); base.view=dz<.02?'frontal':dz<.08?'3/4':'profile-ish'; } }
  if(face?.faceLandmarks?.length){ const l=face.faceLandmarks[0]; base.eyes=eyeOpen(l); base.gaze=gaze(l); const M=face.facialTransformationMatrixes?.[0]; if(M?.data){ const e=eulerFromM4(M.data); base.roll=e.roll.toFixed(1); base.pitch=e.pitch.toFixed(1); base.yaw=e.yaw.toFixed(1);} }
  base.isolated=true; return base; }
function rgbToHsl(r,g,b){ r/=255;g/=255;b/=255; const mx=Math.max(r,g,b),mn=Math.min(r,g,b); let h,s,l=(mx+mn)/2; if(mx===mn){h=s=0;} else { const d=mx-mn; s=l>0.5?d/(2-mx-mn):d/(mx+mn); switch(mx){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;} h/=6;} return [h,s,l]; }
function stddev(a){ const m=a.reduce((x,y)=>x+y,0)/a.length; return Math.sqrt(a.reduce((s,x)=>s+(x-m)*(x-m),0)/a.length); }
function kmeans(pts,k,its=8){ if(!pts.length) return {centroids:[],labels:[]}; const c=pts.slice(0,k).map(p=>p.slice()); let lab=new Array(pts.length).fill(0);
  const d3=(a,b)=>{const dx=a[0]-b[0],dy=a[1]-b[1],dz=a[2]-b[2];return dx*dx+dy*dy+dz*dz;};
  for(let it=0;it<its;it++){ for(let i=0;i<pts.length;i++){ let bi=-1,bd=1e9; for(let j=0;j<k;j++){ const d=d3(pts[i],c[j]); if(d<bd){bd=d;bi=j;} } lab[i]=bi; }
    const s=Array.from({length:k},()=>[0,0,0,0]); for(let i=0;i<pts.length;i++){ const j=lab[i],p=pts[i]; s[j][0]+=p[0];s[j][1]+=p[1];s[j][2]+=p[2];s[j][3]++; }
    for(let j=0;j<k;j++) if(s[j][3]){ c[j][0]=s[j][0]/s[j][3]; c[j][1]=s[j][1]/s[j][3]; c[j][2]=s[j][2]/s[j][3]; } }
  return {centroids:c,labels:lab}; }
function analyzeColor(el,maxSide=160,k=5){ const c=document.createElement('canvas'),cx=c.getContext('2d'); const w=el.naturalWidth,h=el.naturalHeight; const s=Math.min(1,maxSide/Math.max(w,h)); c.width=Math.max(1,(w*s)|0); c.height=Math.max(1,(h*s)|0); cx.drawImage(el,0,0,c.width,c.height); const d=cx.getImageData(0,0,c.width,c.height).data; const pts=[]; let L=[]; for(let i=0;i<d.length;i+=20){ const r=d[i],g=d[i+1],b=d[i+2],a=d[i+3]; if(a<200) continue; const [h1,s1,l]=rgbToHsl(r,g,b); L.push((0.2126*r+0.7152*g+0.0722*b)/255); pts.push([r,g,b]); } const cl=kmeans(pts,k,6).centroids.map(c=>({r:c[0]|0,g:c[1]|0,b:c[2]|0})); const avgL=L.reduce((a,b)=>a+b,0)/(L.length||1); const lighting=avgL>0.7?'bright':avgL<0.35?'dim':'moderate'; const contrast=(stddev(L)>0.18)?'high':'low/med'; return {palette:cl,avg_brightness:+avgL.toFixed(3),tone:'warm',lighting,contrast}; }

/* Prompt engine (safe) */
function buildPrompt(mode){ const parts=[], detail=+detailRange.value;
  if($('infObjects').checked && lastRun.objects?.length){ const items=lastRun.objects.map(o=>`${o.name} ${(o.score*100).toFixed(0)}%`).join(', '); parts.push(`objects: ${items}`); }
  if($('infPose').checked && lastRun.poseSummary){ const p=lastRun.poseSummary; const iso=lastRun?.silhouette?.area ? (lastRun.silhouette.area<0.9?'isolated subject':'subject with background') : 'subject'; parts.push(`subject: ${iso}, view ${p.view||'unknown'}`); parts.push(`pose: shoulders ${p.shoulders_deg||'n/a'}°, hips ${p.hips_deg||'n/a'}°`); }
  if($('infFace').checked && lastRun.poseSummary){ const p=lastRun.poseSummary; const bits=[`eyes ${p.eyes||'unknown'}`,`gaze ${p.gaze||'unknown'}`]; if(p.yaw) bits.push(`yaw ${p.yaw}°`); if(p.pitch) bits.push(`pitch ${p.pitch}°`); if(p.roll) bits.push(`roll ${p.roll}°`); parts.push(`face: ${bits.join(', ')}`); }
  if($('infColor').checked && lastRun.color){ const c=lastRun.color; parts.push(`colors: ${c.palette.map(p=>`#${toHex(p.r)}${toHex(p.g)}${toHex(p.b)}`).join(' ')}`); parts.push(`lighting: ${c.lighting}, contrast ${c.contrast}`); }
  const camera = detail>=60 ? `\n[ camera: 50mm, f/2.8, ISO 200, 1/250 ]` : '';
  let out = `cinematic portrait, ${parts.join(' | ')}${camera}`;
  if(mode==='nsfw_safe'){ out = out.replace(/\b(nude|naked|lingerie|cleavage|see-?through|erotic|fetish|nsfw|breasts?|nipples?|genitals?|vagina|areola)\b/gi,'[redacted]'); nsfwGateEl.textContent='Enabled (redacting)'; }
  else { nsfwGateEl.textContent='Disabled'; }
  if(mode==='edgy') out = `gritty cyber-noir surveillance HUD :: ${out}`;
  if(mode==='poetic') out = `an underground lens reading light and form :: ${out}`;
  if(mode==='numeric') out = JSON.stringify({ shoulders_deg:+(lastRun.poseSummary?.shoulders_deg||0)||null, yaw:+(lastRun.poseSummary?.yaw||0)||null, brightness:lastRun.color?.avg_brightness||null, silhouette_area:(lastRun.silhouette?.area||0) });
  if(mode==='json') out = JSON.stringify({ subject:lastRun.poseSummary||{}, objects:lastRun.objects||[], color:lastRun.color||{}, silhouette:lastRun.silhouette||{} }, null, 2);
  promptOut.value = out; promptChars.textContent = `${out.length} chars`;
}

/* I/O + helpers */
function snapshot(includeOverlays=true){ const c=document.createElement('canvas'); c.width=canvas.width; c.height=canvas.height; const cx=c.getContext('2d'); cx.drawImage(img,0,0,c.width,c.height); if(includeOverlays) cx.drawImage(canvas,0,0); return c.toDataURL('image/png'); }
function chipStates(){ return ['wasm','obj','pose','face','image','run'].map(k=>`${k}:${status[k].classList.contains('ok')?'OK':'ERR'}`).join(' '); }
function webglInfo(){ const c=document.createElement('canvas'); const gl2=c.getContext('webgl2'); const gl=gl2||c.getContext('webgl'); return {webgl2:!!gl2,webgl:!!gl}; }
function diagText(){ const g=webglInfo(); return [
  `UserAgent: ${navigator.userAgent}`,
  `Lang/Platform: ${navigator.language} / ${navigator.platform}`,
  `HW: ${navigator.hardwareConcurrency||'?'} cores, ${navigator.deviceMemory||'?'} GB`,
  `SafeMode: ${safeMode}`,
  `Tasks-Vision: 0.10.21`,
  `Chips: ${chipStates()}`,
  `Img: ${img.naturalWidth||0}x${img.naturalHeight||0} loaded=${img.complete}`,
  `WebGL: v2=${g.webgl2} v1=${g.webgl}`
].join('\n'); }

/* Run */
async function runAll(){
  if (runBtn.disabled){ log('Models not ready. Re-Init or wait for chips to turn OK.', false); return; }
  if (!img.complete || !img.naturalWidth){ setChip(status.image,false,'Image — ERR'); log('No image loaded', false); return; }
  setChip(status.image,true,'Image — OK'); ctx.clearRect(0,0,canvas.width,canvas.height);

  let objs=null, pose=null, face=null;
  try{ if(tgObjects.checked && detector) objs = await detector.detect(img); }catch(e){ log('Object detect failed: '+e.message,false); }
  try{ if(tgPose.checked && poser) pose = await poser.detect(img); }catch(e){ log('Pose detect failed: '+e.message,false); }
  try{ if(tgFace.checked && facer) face = await facer.detect(img); }catch(e){ log('Face detect failed: '+e.message,false); }

  if (tgObjects.checked && objs) drawObjects(objs, +opObjects.value);
  if (tgPose.checked && pose) drawPose(pose, +opPose.value);
  if (tgFace.checked && face) drawFace(face, +opFace.value);
  if (tgBody.checked && pose) drawBodyMesh(pose, +opBody.value);
  let silStats={area:0,bbox:null,height:0}; if (tgSil.checked && pose) silStats = drawSilhouette(pose, +opSil.value);

  /* KPIs */
  objectList.innerHTML=''; const objArr=[];
  if (objs?.detections?.length){ for(const d of objs.detections){ const name=d.categories?.[0]?.categoryName||'object', score=d.categories?.[0]?.score||0; objArr.push({name,score,box:d.boundingBox});
    const li=document.createElement('div'); li.className='pill'; li.innerHTML=`<span>${name}</span><span>${(score*100).toFixed(0)}%</span>`; objectList.appendChild(li);} }
  else objectList.innerHTML='<span class="pill"><span>—</span><span>n/a</span></span>';

  const ps = subjectSummary(pose, face);
  poseList.innerHTML=''; [['View',ps.view||'unknown'],['Shoulders',ps.shoulders_deg?ps.shoulders_deg+'°':'n/a'],['Yaw',ps.yaw?ps.yaw+'°':'n/a'],['Pitch',ps.pitch?ps.pitch+'°':'n/a'],['Roll',ps.roll?ps.roll+'°':'n/a']].forEach(([k,v])=>{
    const li=document.createElement('div'); li.className='pill'; li.innerHTML=`<span>${k}</span><span>${v}</span>`; poseList.appendChild(li);
  });
  subjectList.innerHTML=''; [
    ['Framing',ps.view||'unknown'],
    ['Isolated', silStats.area ? (silStats.area<0.9?'yes':'maybe background heavy') : 'n/a'],
    ['Silhouette area', silStats.area? (silStats.area*100).toFixed(1)+'%':'n/a'],
    ['Silhouette height', silStats.height? Math.round(silStats.height)+'px':'n/a'],
    ['Eyes', ps.eyes||'unknown'], ['Gaze', ps.gaze||'unknown']
  ].forEach(([k,v])=>{ const li=document.createElement('div'); li.className='pill'; li.innerHTML=`<span>${k}</span><span>${v}</span>`; subjectList.appendChild(li); });

  let color=null; try { color=analyzeColor(img); } catch(e){ log('Color analysis skipped (CORS): '+e.message,false); }
  colorList.innerHTML=''; if(color){ const sw=document.createElement('div'); sw.style.display='flex'; sw.style.gap='4px';
    color.palette.forEach(p=>{ const el=document.createElement('div'); el.className='swatch'; el.style.cssText=`width:14px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,.15);background:rgb(${p.r},${p.g},${p.b})`; sw.appendChild(el); });
    colorList.appendChild(sw);
    [['Brightness',color.avg_brightness.toFixed(3)],['Lighting',color.lighting],['Contrast',color.contrast]].forEach(([k,v])=>{ const li=document.createElement('div'); li.className='pill'; li.innerHTML=`<span>${k}</span><span>${v}</span>`; colorList.appendChild(li); });
  } else { const li=document.createElement('div'); li.className='pill'; li.innerHTML=`<span>Color</span><span>n/a</span>`; colorList.appendChild(li); }

  lastRun = { objects: objArr, poseSummary: ps, color, silhouette: silStats };
  setChip(status.run,true,'Detectors — OK'); buildPrompt(modeSel.value); diag.textContent = diagText(); log('Analysis complete ✓', true);
}

/* Init/teardown */
async function closeModels(){ try{await detector?.close();}catch{} try{await poser?.close();}catch{} try{await facer?.close();}catch{} detector=poser=facer=null; runBtn.disabled=true; }
async function init(){
  try{
    visionWasm = await FilesetResolver.forVisionTasks(cfg.WASM); setChip(status.wasm,true,'WASM — OK'); log('WASM ready',true);
    detector = await ObjectDetector.createFromOptions(visionWasm,{ baseOptions:{ modelAssetPath:cfg.OBJ, delegate:'CPU' }, runningMode:'IMAGE', scoreThreshold:.5, maxResults:10 }); setChip(status.obj,true,'Object Model — OK'); log('ObjectDetector ready',true);
    const del = safeMode ? 'CPU' : 'GPU';
    try{ poser = await PoseLandmarker.createFromOptions(visionWasm,{ baseOptions:{ modelAssetPath:cfg.POSE, delegate:del }, runningMode:'IMAGE', numPoses:1 }); }
    catch{ log('Pose GPU failed → CPU',false); poser = await PoseLandmarker.createFromOptions(visionWasm,{ baseOptions:{ modelAssetPath:cfg.POSE, delegate:'CPU' }, runningMode:'IMAGE', numPoses:1 }); }
    setChip(status.pose,true,'Pose Model — OK'); log('PoseLandmarker ready',true);
    try{ facer = await FaceLandmarker.createFromOptions(visionWasm,{ baseOptions:{ modelAssetPath:cfg.FACE, delegate:del }, runningMode:'IMAGE', numFaces:1, outputFacialTransformationMatrixes:true }); }
    catch{ log('Face GPU failed → CPU',false); facer = await FaceLandmarker.createFromOptions(visionWasm,{ baseOptions:{ modelAssetPath:cfg.FACE, delegate:'CPU' }, runningMode:'IMAGE', numFaces:1, outputFacialTransformationMatrixes:true }); }
    setChip(status.face,true,'Face Model — OK'); log('FaceLandmarker ready',true);
    runBtn.disabled=false;
  }catch(e){
    log('Init error: '+(e?.message||e), false);
    if(!visionWasm) setChip(status.wasm,false,'WASM — ERR');
    if(!detector) setChip(status.obj,false,'Object Model — ERR');
    if(!poser) setChip(status.pose,false,'Pose Model — ERR');
    if(!facer) setChip(status.face,false,'Face Model — ERR');
  }
  diag.textContent = diagText();
}

/* Events */
window.addEventListener('resize', resize);
img.addEventListener('load', async ()=>{ resize(); setChip(status.image,true,'Image — OK'); try{ if(!runBtn.disabled) await runAll(); }catch(e){ log('Auto-run failed: '+e.message,false);} });
demoBtn.addEventListener('click', ()=>{ log('Loading demo image…'); img.src=cfg.DEMO; });
fileInput.addEventListener('change', (e)=>{ const f=e.target.files?.[0]; if(!f) return; const url=URL.createObjectURL(f); log('Loading local image…'); img.src=url; });
runBtn.addEventListener('click', runAll);
['change','input'].forEach(evt=>{
  [tgObjects,tgPose,tgFace,tgBody,tgSil].forEach(el=>el.addEventListener(evt,()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); runAll(); }));
  [opObjects,opPose,opFace,opBody,opSil].forEach(el=>el.addEventListener(evt, runAll));
  modeSel.addEventListener(evt, ()=>buildPrompt(modeSel.value));
  detailRange.addEventListener(evt, ()=>buildPrompt(modeSel.value));
  ['infObjects','infPose','infFace','infColor'].forEach(id=>$(id).addEventListener(evt, ()=>buildPrompt(modeSel.value)));
});
overlayTestBtn.addEventListener('click', ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save(); ctx.strokeStyle='#9ad1ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(canvas.width,canvas.height); ctx.moveTo(canvas.width,0); ctx.lineTo(0,canvas.height); ctx.stroke(); ctx.font='16px ui-sans-serif'; ctx.fillStyle='#9ad1ff'; ctx.fillText('OVERLAY OK',12,22); ctx.restore(); log('Overlay test drawn ✓', true); });
reinitBtn.addEventListener('click', async ()=>{ log('Re-initializing models…'); try{ await closeModels(); await init(); log('Re-init complete ✓', true);}catch(e){ log('Re-init failed: '+e.message,false); }});
selfTestBtn.addEventListener('click', ()=>{ diag.textContent=diagText(); log('Self-test captured environment ✓', true); });
copyDiagBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(diag.textContent||diagText()); log('Diagnostics copied ✓', true);}catch{ log('Copy failed', false); }});

/* Boot */
log('Booting BlackSite HUD…'); await init(); log('Load Demo or Upload, then Run.'); (function tick(){ fps.frames++; const now=performance.now(); if(!fps.t0) fps.t0=now; const dt=now-fps.t0; if(dt>500){ const fpsv=(fps.frames/(dt/1000)).toFixed(1); fpsChip.textContent=`FPS — ${fpsv}`; fps.t0=now; fps.frames=0; } requestAnimationFrame(tick); })();

/* Exports + prompt buttons */
$('exportPng').addEventListener('click', ()=>{ const url=snapshot(true); const a=document.createElement('a'); a.href=url; a.download=`snapshot_${Date.now()}.png`; a.click(); });
exportOverlays.addEventListener('click', ()=>{ const url=snapshot(false); const a=document.createElement('a'); a.href=url; a.download=`overlays_${Date.now()}.png`; a.click(); });
copyPrompt.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(promptOut.value); log('Prompt copied ✓', true);}catch{ log('Clipboard failed', false);} });
downloadPrompt.addEventListener('click', ()=>{ const blob=new Blob([promptOut.value],{type:'text/plain'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`prompt_${Date.now()}.txt`; a.click(); URL.revokeObjectURL(a.href); });
</script>
</body>
</html>
