<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PF — ImageIntel (Persistent Image + Next-Level Preview)</title>
<meta name="robots" content="noindex,nofollow"/>
<meta name="description" content="ImageIntel with unbreakable base image (IMG layer) and animated measurement overlay (Canvas). Multi-face, preview scan, NSFW heuristics-ready."/>
<style>
:root{
  --bg:#0b0f14; --ink:#d6f5ff; --edge:#232a33; --aqua:#64f2e3; --ok:#55d69a; --bad:#ff6b6b; --warn:#ffd166; --dim:#9db1bd;
}
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:ui-monospace,Menlo,Consolas,monospace}
.wrap{max-width:1180px;margin:0 auto;padding:16px}
h1{margin:0 0 10px;font-size:1.1rem}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
.badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0b1117dd}
.ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)} .note{color:var(--dim)}
.btn{cursor:pointer;border:1.5px solid var(--aqua);background:#131922;color:#b8fff6;padding:8px 12px;border-radius:10px;font-weight:700}
.btn:hover{background:var(--aqua);color:#0e131a;border-color:#fff}
.btn:disabled{opacity:.5;cursor:not-allowed}
.stepper{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:12px 0}
.step{border:1px solid var(--edge);border-radius:10px;padding:10px;background:#0f161f}
.step.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}

.stage{position:relative;border:1px solid var(--edge);border-radius:12px;background:#0d131a;overflow:hidden}
.inner{position:relative;aspect-ratio:16/9}
#baseImg{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;object-position:center center;display:block;user-select:none;pointer-events:none}
#over{position:absolute;inset:0;width:100%;height:100%;display:block}

.legend{position:absolute;left:12px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
.scanGlow{position:absolute;left:0;top:0;height:2px;background:linear-gradient(90deg, transparent, #64f2e3, transparent);box-shadow:0 0 12px #64f2e3aa;opacity:.0;pointer-events:none}

.tab-head{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
.tab-head button{cursor:pointer;border:1px solid var(--edge);background:#0e141a;color:#ink;padding:8px 12px;border-radius:9px;color:var(--ink)}
.tab-head button.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.tab{display:none;margin-top:10px;border:1px solid var(--edge);border-radius:12px;padding:12px;background:#0e141a}
.tab.active{display:block}
textarea.out{width:100%;min-height:120px;background:#0b1117;color:#d8faff;border:1px solid #1b242e;border-radius:8px;padding:10px}

.toastbox{position:fixed;right:14px;bottom:14px;display:flex;flex-direction:column;gap:10px;z-index:5000}
.toast{background:#121823ee;border:1px solid var(--edge);color:#defaff;padding:10px 12px;border-radius:10px;min-width:220px;box-shadow:0 4px 18px #0006}

.diag{margin-top:12px;border:1px dashed var(--edge);padding:10px;border-radius:10px;background:#0c1117}
.kv{display:grid;grid-template-columns:160px 1fr;gap:6px 12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>ImageIntel — Persistent Image + Animated Overlay</h1>

  <!-- Status -->
  <div class="row">
    <span class="badge">Init: <b id="initState">booting…</b></span>
    <span class="badge">Bundle: <b id="bundleState">…</b></span>
    <span class="badge">Model: <b id="modelState">…</b></span>
  </div>

  <!-- Stage -->
  <div class="stage">
    <div class="inner" id="stage">
      <!-- Base image stays visible no matter what -->
      <img id="baseImg" alt=""/>
      <!-- Overlay canvas for all drawings -->
      <canvas id="over"></canvas>
      <div id="scanLine" class="scanGlow"></div>
      <div class="legend">
        <span class="badge">faces: <span id="faceCount">0</span></span>
        <span class="badge">active face: <span id="activeFaceIdx">—</span></span>
      </div>
    </div>
  </div>

  <!-- Wizard -->
  <div class="stepper">
    <div class="step active" id="s1">
      <h3>Step 1 — Load</h3>
      <div class="row">
        <input id="file" type="file" accept="image/*"/>
        <button class="btn" id="demo">Load Demo</button>
        <button class="btn" id="next1" disabled>Next</button>
      </div>
      <div class="note">Pick any image. It will appear immediately below and stay visible (IMG layer).</div>
    </div>

    <div class="step" id="s2">
      <h3>Step 2 — Options</h3>
      <div class="row">
        <label><input type="checkbox" id="scanFace" checked> Face</label>
        <label><input type="checkbox" id="scanBody"> Body</label>
        <label><input type="checkbox" id="scanNSFW"> NSFW</label>
        <label><input type="checkbox" id="scanObjects"> Objects</label>
      </div>
      <div class="row">
        <label>Detail <input id="detail" type="range" min="1" max="3" step="1" value="2"></label>
        <label>Spice <input id="spice" type="range" min="0" max="3" step="1" value="1"></label>
      </div>
      <div class="row">
        <button class="btn" id="preview">Preview Overlay</button>
        <button class="btn" id="next2">Next</button>
      </div>
    </div>

    <div class="step" id="s3">
      <h3>Step 3 — Cloud (optional)</h3>
      <div class="row">
        <label><input type="checkbox" id="useCloud"> HuggingFace</label>
        <input id="hfToken" placeholder="hf_... token" style="min-width:320px;border:1px solid var(--edge);background:#0f141a;color:#fff;padding:6px 10px;border-radius:8px">
        <button class="btn" id="run">Run Analysis</button>
      </div>
      <div class="note">BLIP caption / CLIP Interrogator / DETR objects (if enabled).</div>
    </div>

    <div class="step" id="s4">
      <h3>Step 4 — Results</h3>
      <div class="row" id="faceSelector"></div>
      <div class="row">
        <button class="btn" id="copySFW" disabled>Copy SFW</button>
        <button class="btn" id="copyNSFW" disabled>Copy NSFW</button>
        <button class="btn" id="exportJSON" disabled>Export JSON</button>
        <button class="btn" id="rerun">Re-Run</button>
      </div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tab-head">
    <button class="active" data-tab="sfw">SFW Prompt</button>
    <button data-tab="nsfw">NSFW Prompt</button>
    <button data-tab="meas">Measurements</button>
    <button data-tab="json">JSON</button>
    <button data-tab="diag">Diagnostics</button>
  </div>
  <div id="tab_sfw" class="tab active"><textarea id="outSFW" class="out" readonly></textarea></div>
  <div id="tab_nsfw" class="tab"><textarea id="outNSFW" class="out" readonly></textarea></div>
  <div id="tab_meas" class="tab"><textarea id="outMeas" class="out" readonly></textarea></div>
  <div id="tab_json" class="tab"><textarea id="outJson" class="out" readonly></textarea></div>
  <div id="tab_diag" class="tab">
    <div class="diag">
      <div class="kv">
        <div>UA:</div><div id="ua"></div>
        <div>Base natural:</div><div id="naturalSz">—</div>
        <div>Rendered box:</div><div id="renderedSz">—</div>
        <div>Canvas:</div><div id="canvasSz">—</div>
        <div>Last event:</div><div id="last">ready</div>
      </div>
    </div>
  </div>
</div>

<div class="toastbox" id="toastbox"></div>

<script type="module">
/* =================== Basic UI/Toast =================== */
const $=id=>document.getElementById(id);
const toastbox=$('toastbox');
const toast=(msg)=>{const d=document.createElement('div');d.className='toast';d.textContent=msg;toastbox.appendChild(d);setTimeout(()=>d.remove(),2600);};
$('ua').textContent=navigator.userAgent;
const setLast=t=>{$('last').textContent=String(t)};

/* =================== Persistent Image Layer =================== */
const baseImg=$('baseImg');     // <img> is the base layer (never clears)
const over=$('over');           // overlay canvas on top
const octx=over.getContext('2d');
const stage=$('stage');
let imgReady=false;
let imgNatural={w:0,h:0};
let imgBox={x:0,y:0,w:0,h:0};   // actual rendered box inside stage (object-fit:contain)

/* Keep overlay canvas exactly on top of the rendered image box */
function updateBoxes(){
  const s=stage.getBoundingClientRect();
  const i=baseImg.getBoundingClientRect();
  // Canvas is full stage, but we track the inner image box to map coords
  over.width = Math.max(1, Math.round(s.width));
  over.height= Math.max(1, Math.round(s.height));
  over.style.width = s.width+'px';
  over.style.height= s.height+'px';
  imgBox = { x: Math.round(i.left - s.left), y: Math.round(i.top - s.top), w: Math.round(i.width), h: Math.round(i.height) };
  $('renderedSz').textContent=`${imgBox.w}×${imgBox.h} @ (${imgBox.x},${imgBox.y})`;
  $('canvasSz').textContent=`${over.width}×${over.height}`;
}

new ResizeObserver(updateBoxes).observe(stage);
window.addEventListener('resize', updateBoxes, {passive:true});
document.addEventListener('scroll', updateBoxes, {passive:true}); // keep in sync on scroll, no redraw loss

/* File load (use FileReader -> <img src=dataURL>) */
function enableNext(){ $('next1').disabled=false; }
function loadFromFile(file){
  if(!file){ toast('No file'); return; }
  const reader=new FileReader();
  reader.onload=()=>{
    baseImg.onload=()=>{
      imgReady=true;
      imgNatural={w:baseImg.naturalWidth, h:baseImg.naturalHeight};
      $('naturalSz').textContent=`${imgNatural.w}×${imgNatural.h}`;
      updateBoxes();
      enableNext();
      toast('Image loaded.');
      setLast('image onload OK');
    };
    baseImg.onerror=()=>{ imgReady=false; toast('Image decode error'); };
    baseImg.src=reader.result;
    baseImg.alt=file.name||'image';
  };
  reader.onerror=()=>{ toast('File read error'); };
  reader.readAsDataURL(file);
}

/* Demo image (tiny base64) */
const demoPng="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANAAAADQCAYAAAD3QmL4AAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVR4nO3TwQmDQBQF0eT9T2iZgQq3Zy7y1qkH1bYw+5h4v5yKp1lGgAAAAAAAAAAAAAAAPzXr8nqGk9i2y3bG2wqk9gRz8yVwz5w7k1m0t0b3m4v0bq9wq3g5w4e3Qv6wz7P3vTgPpJkAAJ4w0n8C3q7v9v0FJr7nYt9b3x2cW3O2mXxg7iB9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ+eGgAA+S9cFf7r+f3bJrS6cV7fNw9u8s7xw7v+f2C6v7p/8eZ7c4+f3b8v7n+DDkAAE9h8gMAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAoB1B/0iJ7o9J0c9AAAAAElFTkSuQmCC";

/* Wiring for Step 1 */
$('file').addEventListener('change', e=>{ const f=e.target.files?.[0]; loadFromFile(f); });
$('demo').addEventListener('click', ()=>{ baseImg.onload=()=>{ imgReady=true; imgNatural={w:baseImg.naturalWidth,h:baseImg.naturalHeight}; $('naturalSz').textContent=`${imgNatural.w}×${imgNatural.h}`; updateBoxes(); enableNext(); toast('Demo image loaded.'); }; baseImg.src=demoPng; baseImg.alt='demo'; });
function setStep(n){
  ['s1','s2','s3','s4'].forEach((id,i)=>$(id).classList.toggle('active',(i+1)===n));
  // nothing to redraw; IMG persists; just update overlay sizing
  updateBoxes();
}
setStep(1);
$('next1').addEventListener('click', ()=>setStep(2));
$('next2').addEventListener('click', ()=>setStep(3));
$('rerun').addEventListener('click', ()=>setStep(2));

/* =================== MediaPipe bundle & models =================== */
$('initState').textContent='loading bundle…';
let FilesetResolver, FaceLandmarker, PoseLandmarker, DrawingUtils, face=null, pose=null;

(async ()=>{
  try{
    const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs");
    ({FilesetResolver, FaceLandmarker, PoseLandmarker, DrawingUtils} = vision);
    $('bundleState').innerHTML='<span class="ok">OK</span>';
    $('initState').textContent='loading models…';
    const fs = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
    face = await FaceLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"}, runningMode:'IMAGE', numFaces:5 });
    pose = await PoseLandmarker.createFromOptions(fs,{ baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task"}, runningMode:'IMAGE' });
    $('modelState').innerHTML='<span class="ok">OK</span>';
    $('initState').textContent='ready';
  }catch(e){
    $('bundleState').innerHTML='<span class="bad">FAIL</span>';
    $('modelState').innerHTML='<span class="bad">FAIL</span>';
    $('initState').textContent='init error';
  }
})();

/* =================== Overlay drawing utils =================== */
const faceCountEl=$('faceCount');
const activeFaceIdxEl=$('activeFaceIdx');
const faceSelector=$('faceSelector');
const outSFW=$('outSFW'), outNSFW=$('outNSFW'), outMeas=$('outMeas'), outJson=$('outJson');
const copySFW=$('copySFW'), copyNSFW=$('copyNSFW'), exportJSON=$('exportJSON');
const scanFace=$('scanFace'), scanBody=$('scanBody'), scanNSFW=$('scanNSFW'), scanObjects=$('scanObjects');
const detail=$('detail'), spice=$('spice');
const useCloud=$('useCloud'), hfToken=$('hfToken');

let analysis=null, activeFace=0;
function mapNormToBox(p){ // MediaPipe normalized 0..1 -> imgBox coords
  return { x: imgBox.x + p.x*imgBox.w, y: imgBox.y + p.y*imgBox.h, z: p.z };
}
function dist(a,b,lm){ return Math.hypot(lm[a].x-lm[b].x, lm[a].y-lm[b].y); }
function eyeAngleDeg(lm){ const a=133,b=362; return +(Math.atan2(lm[b].y-lm[a].y, lm[b].x-lm[a].x)*180/Math.PI).toFixed(2); }
function bbox(lm){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of lm){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function classify(jaw_face,cheek_face){ if(jaw_face<0.45 && cheek_face<0.55) return 'oval'; if(Math.abs(jaw_face-cheek_face)<0.03 && jaw_face>0.5) return 'round'; if(jaw_face>=0.55 && cheek_face>=0.6) return 'square'; if(cheek_face>jaw_face+0.07) return 'heart'; return 'triangle'; }

/* Animated scanner line (y sweeps over the visible image box) */
let rafId=null, sweepY=0, scanning=false;
function startScan(){
  scanning=true; sweepY=imgBox.y;
  const scanLine=$('scanLine');
  scanLine.style.opacity='.9';
  function tick(){
    if(!scanning) return;
    // position scan line across the image box only
    scanLine.style.top = (sweepY)+'px';
    scanLine.style.left = imgBox.x+'px';
    scanLine.style.width = imgBox.w+'px';
    // progressive overlay reveal
    drawOverlay(sweepY);
    sweepY += Math.max(2, imgBox.h/40);
    if(sweepY > imgBox.y + imgBox.h){ stopScan(); drawOverlay(null,true); return; }
    rafId=requestAnimationFrame(tick);
  }
  rafId=requestAnimationFrame(tick);
}
function stopScan(){
  scanning=false;
  cancelAnimationFrame(rafId);
  const scanLine=$('scanLine'); scanLine.style.opacity='0';
}

/* Draw overlay; if clipY provided, clip to that Y inside image box */
function drawOverlay(clipY=null, forceFull=false){
  octx.clearRect(0,0,over.width,over.height);
  if(!analysis?.faces?.length) return;
  if(clipY!==null && !forceFull){
    octx.save(); octx.beginPath(); octx.rect(imgBox.x, imgBox.y, imgBox.w, Math.max(0, Math.min(imgBox.h, clipY - imgBox.y))); octx.clip();
  }
  const d=new DrawingUtils(octx);
  analysis.faces.forEach((f,idx)=>{
    const lm=f.landmarks_canvas;
    const mainCol = idx===activeFace?'rgba(100,242,227,.95)':'rgba(100,242,227,.35)';
    try{ d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_TESSELLATION, {color:mainCol,lineWidth:.9}); }catch{}
    d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE,     {color:'rgba(255,255,255,.85)',lineWidth:2});
    d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,      {color:'rgba(255,255,255,.85)',lineWidth:2});
    d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_LIPS,          {color:'rgba(255,120,160,.9)',lineWidth:2});
    d.drawConnectors(lm, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL,     {color:'rgba(140,255,220,.9)',lineWidth:2});
    if(f.nsfw?.chest_rect){
      const r=f.nsfw.chest_rect; octx.save(); octx.setLineDash([6,5]); octx.strokeStyle='rgba(255,120,160,.85)'; octx.lineWidth=2;
      octx.strokeRect(r.x,r.y,r.w,r.h); octx.restore();
    }
  });
  if(clipY!==null && !forceFull) octx.restore();
}

/* Build text outputs */
function buildOutputs(){
  const f=analysis?.faces?.[activeFace];
  if(!f){ outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=JSON.stringify(analysis||{},null,2); return; }
  const sfw = `portrait, ${f.shape} face, jaw/face ${f.ratios.jaw_face}, cheek/face ${f.ratios.cheek_face}, eye angle ${f.measures.eye_angle_deg}°, hair ${f.palette.hair}, skin ${f.palette.skin}, eyes ${f.palette.eyes}`;
  const nsfw = scanNSFW.checked ? (f.nsfw?.breast_size ? `${f.nsfw.breast_size} breasts, ${f.nsfw.nipples_visible?'visible nipples':'covered'}` : 'nsfw heuristics: none') : '';
  outSFW.value=sfw; outNSFW.value=nsfw;
  outMeas.value=`H ${f.measures.face_height}px, jaw ${f.measures.jaw_width}px, cheek ${f.measures.cheek_width}px`;
  outJson.value=JSON.stringify(analysis,null,2);
  copySFW.disabled=false; exportJSON.disabled=false; copyNSFW.disabled=!scanNSFW.checked;
}

/* Face pills */
function mkFacePills(){
  faceSelector.innerHTML='';
  (analysis.faces||[]).forEach((f,idx)=>{
    const b=document.createElement('button'); b.className='btn'; b.textContent='Face '+idx;
    b.addEventListener('click', ()=>{ activeFace=idx; activeFaceIdxEl.textContent=idx; drawOverlay(null,true); buildOutputs(); });
    faceSelector.appendChild(b);
  });
}

/* =================== Preview Overlay (Step 2) =================== */
$('preview').addEventListener('click', async ()=>{
  if(!imgReady){ toast('Load an image first.'); return; }
  if(!face){ toast('Model not ready yet'); return; }
  setLast('preview start');
  // Detect faces **from the IMG element** (robust; no canvas readback)
  const res = await face.detect(baseImg).catch(()=>null);
  const landmarks = res?.faceLandmarks || [];
  faceCountEl.textContent=landmarks.length;
  if(!landmarks.length){ analysis=null; octx.clearRect(0,0,over.width,over.height); outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=''; toast('No faces found'); return; }

  // Compute canvas-space landmarks using object-fit box mapping
  const facesOut=[];
  // quick helpers pulling pixel data from screen (for colors/NSFW heuristics)
  // Create a screen snapshot of the visible area (overlay canvas) by drawing the IMG to a temp canvas sized to the *rendered box*:
  const snap=document.createElement('canvas'); snap.width=imgBox.w; snap.height=imgBox.h;
  const sctx=snap.getContext('2d',{willReadFrequently:true}); sctx.drawImage(baseImg, 0,0, imgBox.w, imgBox.h);
  const snapData=sctx.getImageData(0,0,imgBox.w,imgBox.h);

  function avgRectHex_local(x,y,w,h,step=2){
    const d=snapData.data; const W=snap.width; const H=snap.height;
    const x0=Math.max(0,Math.floor(x)),y0=Math.max(0,Math.floor(y)),x1=Math.min(W,Math.floor(x+w)),y1=Math.min(H,Math.floor(y+h));
    let R=0,G=0,B=0,c=0; for(let yy=y0;yy<y1;yy+=step){ for(let xx=x0;xx<x1;xx+=step){ const i=(yy*W+xx)*4; R+=d[i]; G+=d[i+1]; B+=d[i+2]; c++; } }
    if(!c) return '#000000'; R=(R/c)|0; G=(G/c)|0; B=(B/c)|0; return '#'+[R,G,B].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  for(let fi=0; fi<landmarks.length; fi++){
    const lmN=landmarks[fi];
    const lmC=lmN.map(p=>mapNormToBox(p)); // map to overlay coords
    const Hpx=dist(10,152,lmC), Jpx=dist(234,454,lmC), Cpx=dist(234,454,lmC);
    const eyeDeg=eyeAngleDeg(lmC);
    const ratios={jaw_face:+(Jpx/Hpx).toFixed(3), cheek_face:+(Cpx/Hpx).toFixed(3)};
    const shape=classify(ratios.jaw_face,ratios.cheek_face);
    const bb=bbox(lmC); const fW=bb.maxX-bb.minX, fH=bb.maxY-bb.minY;

    // sample colors from the *snapshot* (imgBox space)
    const hair = avgRectHex_local(bb.minX - imgBox.x, Math.max(0,bb.minY-imgBox.y-12), fW, 10, 1);
    const skin = avgRectHex_local((bb.minX - imgBox.x)+0.35*fW, (bb.minY - imgBox.y)+0.45*fH, 18,18, 1);
    const e=lmC[133]; const eyes = avgRectHex_local((e.x-imgBox.x)-8,(e.y-imgBox.y)-8, 16,16, 1);

    // crude NSFW chest box anchored below face:
    let nsfw=null;
    if(scanNSFW.checked){
      const cx=(bb.minX+bb.maxX)/2;
      let rect={x:cx-0.68*fW, y:bb.maxY+0.12*fH, w:1.36*fW, h:1.10*fH};
      // clamp to image box
      rect.x=Math.max(imgBox.x,rect.x); rect.y=Math.max(imgBox.y,rect.y);
      if(rect.x+rect.w>imgBox.x+imgBox.w) rect.w=imgBox.x+imgBox.w-rect.x;
      if(rect.y+rect.h>imgBox.y+imgBox.h) rect.h=imgBox.y+imgBox.h-rect.y;
      // very basic visible-skin ratio within rect using snapshot:
      const sx=Math.max(0,Math.floor(rect.x-imgBox.x)), sy=Math.max(0,Math.floor(rect.y-imgBox.y)), sw=Math.floor(rect.w), sh=Math.floor(rect.h);
      let skinCnt=0, tot=0; const d=snapData.data, W=snap.width;
      for(let yy=sy;yy<sy+sh;yy+=2){ for(let xx=sx;xx<sx+sw;xx+=2){ const i=(yy*W+xx)*4; const r=d[i],g=d[i+1],b=d[i+2];
        const y=0.299*r+0.587*g+0.114*b, cb=-0.168736*r-0.331264*g+0.5*b+128, cr=0.5*r-0.418688*g-0.081312*b+128;
        if(cb>77&&cb<127&&cr>133&&cr<173&&y>40) skinCnt++; tot++;
      }}
      const skinRatio=tot?skinCnt/tot:0;
      const chestRatio=rect.w/Hpx; let breast='unknown';
      if(skinRatio>0.55){ if(chestRatio<1.55) breast='small'; else if(chestRatio<2.05) breast='medium'; else breast='large'; }
      nsfw={chest_rect:rect, chest_skin_ratio:+skinRatio.toFixed(3), breast_size:breast, nipples_visible:(skinRatio>0.55)};
    }

    facesOut.push({
      index:fi,
      measures:{face_height:+Hpx.toFixed(2), jaw_width:+Jpx.toFixed(2), cheek_width:+Cpx.toFixed(2), eye_angle_deg:eyeDeg},
      ratios, shape, palette:{hair,skin,eyes},
      landmarks_canvas:lmC, nsfw
    });
  }

  analysis={version:'pf_facemapper_3_plus', frame:{type:'image'},
            image:{natural:imgNatural, box:imgBox}, faces:facesOut, pose:null, scene:{bgTag:'heuristic'}, cloud:null};

  faceCountEl.textContent=facesOut.length; activeFace=0; activeFaceIdxEl.textContent=facesOut.length?0:'—';
  mkFacePills(); buildOutputs();
  // animate the scan reveal over the IMG (never disappears on scroll)
  startScan();
  setTimeout(()=>drawOverlay(null,true), 1600); // settle to full overlay
  setTimeout(()=>stopScan(), 1600);
  setLast('preview done');
});

/* =================== Full Analysis (Step 3→4) =================== */
$('run').addEventListener('click', async ()=>{
  if(!imgReady){ toast('Load an image first.'); return; }
  // For now, reuse preview analysis as the base; cloud calls can append later
  if(!analysis) { $('preview').click(); }
  setStep(4);
  buildOutputs();
});

/* =================== Tabs & basic actions =================== */
document.querySelectorAll('.tab-head button').forEach(b=>{
  b.addEventListener('click',()=>{
    document.querySelectorAll('.tab-head button').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    const t=document.getElementById('tab_'+b.dataset.tab); if(t) t.classList.add('active');
  });
});
copySFW.addEventListener('click',()=>navigator.clipboard.writeText(outSFW.value||'').then(()=>toast('Copied SFW')));
copyNSFW.addEventListener('click',()=>navigator.clipboard.writeText(outNSFW.value||'').then(()=>toast('Copied NSFW')));
exportJSON.addEventListener('click',()=>{
  const blob=new Blob([outJson.value||'{}'],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='imageintel.json'; document.body.appendChild(a); a.click();
  setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);},150);
});

/* =================== UX polish =================== */
detail.addEventListener('input', ()=>{ if(analysis){ buildOutputs(); drawOverlay(null,true);} });
spice.addEventListener('input',  ()=>{ if(analysis){ buildOutputs(); drawOverlay(null,true);} });

</script>
</body>
</html>
