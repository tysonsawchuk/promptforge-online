<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ImageIntel Pro Visor — Fixed Test Build (Face • Pose • Segments)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#121822; --ink:#e9fbff; --mut:#9fb3c0; --aqua:#64f2e3; --hot:#ff4d9a; --lime:#a8ff60; --gold:#ffd166;
    --red:#ff6b6b; --green:#52ffa8; --blue:#59baff; --vio:#be9cff;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{margin:.2rem 0 .4rem;font-weight:800}
  .sub{color:var(--mut);margin:0 0 1rem}
  .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  @media(max-width:1100px){.grid{grid-template-columns:1fr}}
  .card{background:var(--panel);border:1px solid #1e2835;border-radius:14px;box-shadow:0 8px 24px #0005;overflow:hidden}
  .card h2{margin:0;padding:10px 12px;border-bottom:1px solid #1b2531;background:#0e141c;font-size:1rem}
  .pad{padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#182130;border:1px solid #2a3445;color:var(--aqua);padding:8px 12px;border-radius:9px;font-weight:700;cursor:pointer}
  .btn:hover{border-color:#3c4d64;background:#1a2738}
  .btn.primary{background:#1d3147;border-color:#355773;color:#e9fbff}
  .btn.warn{background:#2a2412;border-color:#6a4; color:#efe6c8}
  .input{background:#0f1621;border:1px solid #233044;color:#bfefff;border-radius:8px;padding:8px 10px;min-width:240px}
  .mini{font-size:.9rem;color:var(--mut)}
  .stage{position:relative;display:inline-block;max-width:100%}
  .stage img{display:block;max-width:100%;height:auto;border-radius:10px;border:1px solid #1d2632}
  canvas.layer{position:absolute;left:0;top:0;pointer-events:none}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;background:#0e1722;border:1px solid #243246;color:#9ad7ff;font-size:.8rem}
  .diag{font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.9rem;line-height:1.35;white-space:pre-wrap}
  .good{color:var(--green)} .warn{color:var(--gold)} .bad{color:var(--red)} .mut{color:#9fb3c0}
</style>
</head>
<body>
<div class="wrap">
  <h1>ImageIntel Pro Visor — Fixed Test Build</h1>
  <p class="sub">MediaPipe Tasks (Face • Pose • Segments) with crisp overlays. Cloud + NSFW wiring hooks are stubbed but won’t block locals.</p>

  <div class="grid">
    <!-- LEFT: STAGE -->
    <div class="card">
      <h2>Stage</h2>
      <div class="pad">
        <div class="row">
          <input type="file" id="fileInput" accept="image/*" class="input"/>
          <button class="btn" id="btnDemo">Load Demo</button>
          <button class="btn" id="btnFit">Fit Canvases</button>
          <button class="btn warn" id="btnSelfTest">Self-Test</button>
        </div>
        <div class="mini" id="imgMeta">No image loaded.</div>
        <div style="height:10px"></div>
        <div id="stage" class="stage">
          <img id="imgEl" alt="preview"/>
          <canvas id="cvFace" class="layer"></canvas>
          <canvas id="cvPose" class="layer"></canvas>
          <canvas id="cvSeg"  class="layer"></canvas>
        </div>
      </div>
    </div>

    <!-- RIGHT: CONTROLS -->
    <div class="card">
      <h2>Controls</h2>
      <div class="pad">
        <div class="row">
          <label class="mini"><input type="checkbox" id="optFace" checked/> Face</label>
          <label class="mini"><input type="checkbox" id="optPose" checked/> Pose</label>
          <label class="mini"><input type="checkbox" id="optSeg"  checked/> Segments</label>
        </div>
        <div class="row" style="margin-top:6px">
          <button class="btn primary" id="btnAnalyze">Analyze (A→B→C)</button>
          <button class="btn" id="btnClear">Clear Overlays</button>
        </div>
        <div style="margin-top:10px">
          <span class="pill">DPR: <span id="kDpr">–</span></span>
          <span class="pill">Image: <span id="kImg">–</span></span>
          <span class="pill">Canvas: <span id="kCan">–</span></span>
        </div>
      </div>
    </div>
  </div>

  <!-- DIAGNOSTICS -->
  <div class="card" style="margin-top:16px">
    <h2>Diagnostics</h2>
    <div class="pad">
      <div id="log" class="diag"></div>
    </div>
  </div>
</div>

<!-- LIBS: MediaPipe Tasks Vision web bundle -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13/vision_bundle.js"></script>

<script>
(function(){
  const $ = s=>document.querySelector(s);
  const logEl = $('#log');
  const imgEl = $('#imgEl');
  const cvFace = $('#cvFace'), cvPose = $('#cvPose'), cvSeg = $('#cvSeg');
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  $('#kDpr').textContent = DPR.toFixed(2);

  const MODEL = {
    face: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
    pose: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
    segm: "https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_multiclass_256x256/float16/1/selfie_multiclass_256x256.task"
  };

  let fileset = null, faceLM = null, poseLM = null, segm = null, drawFace = null, drawPose = null;

  function log(msg, cls='mut'){
    const d=document.createElement('div'); d.className=cls; d.textContent=msg;
    logEl.prepend(d);
  }

  function fitCanvases(){
    if (!imgEl.naturalWidth) { log('No image to fit', 'warn'); return; }
    const rect = imgEl.getBoundingClientRect();
    [cvFace, cvPose, cvSeg].forEach(cv=>{
      const ctx=cv.getContext('2d');
      cv.style.width  = rect.width + 'px';
      cv.style.height = rect.height + 'px';
      cv.width  = Math.max(1, Math.round(rect.width  * DPR));
      cv.height = Math.max(1, Math.round(rect.height * DPR));
      ctx.setTransform(DPR,0,0,DPR,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.clearRect(0,0,cv.width,cv.height);
    });
    $('#kImg').textContent = imgEl.naturalWidth + '×' + imgEl.naturalHeight;
    $('#kCan').textContent = Math.round(cvFace.width/DPR) + '×' + Math.round(cvFace.height/DPR);
  }

  async function ensureTasks(){
    if (faceLM && poseLM && segm) return true;
    const wasmRoot = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13/wasm";
    if (!window.vision || !window.vision.FilesetResolver){
      log('MediaPipe vision bundle missing or blocked', 'bad');
      return false;
    }
    fileset = await window.vision.FilesetResolver.forVisionTasks(wasmRoot);

    faceLM = await window.vision.FaceLandmarker.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: MODEL.face },
      numFaces: 1, runningMode: "IMAGE",
      outputFaceBlendshapes: true,
      outputFacialTransformationMatrixes: true
    });
    poseLM = await window.vision.PoseLandmarker.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: MODEL.pose },
      runningMode: "IMAGE", numPoses: 1
    });
    segm = await window.vision.ImageSegmenter.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: MODEL.segm },
      runningMode: "IMAGE", outputCategoryMask: true
    });

    drawFace = new window.vision.DrawingUtils(cvFace.getContext('2d'));
    drawPose = new window.vision.DrawingUtils(cvPose.getContext('2d'));
    log('MediaPipe tasks ready', 'good');
    return true;
  }

  function clearOverlays(){
    [cvFace,cvPose,cvSeg].forEach(cv=>cv.getContext('2d').clearRect(0,0,cv.width,cv.height));
  }

  function imageToCanvasSource(){
    // MP can take HTMLImageElement directly; we’ll also provide a display-sized canvas to keep scale consistent
    const r = imgEl.getBoundingClientRect();
    const c = document.createElement('canvas');
    c.width = Math.max(1, Math.round(r.width)); 
    c.height= Math.max(1, Math.round(r.height));
    c.getContext('2d').drawImage(imgEl, 0, 0, c.width, c.height);
    return c; // HTMLCanvasElement is a valid ImageSource
  }

  async function analyze(){
    if (!imgEl.naturalWidth){ log('Load an image first', 'warn'); return; }
    const ok = await ensureTasks(); if(!ok) return;
    fitCanvases(); clearOverlays();

    const wantFace = $('#optFace').checked;
    const wantPose = $('#optPose').checked;
    const wantSegm = $('#optSeg').checked;

    const src = imageToCanvasSource();

    // FACE
    if (wantFace){
      const t0=performance.now();
      const res = faceLM.detect(src);
      const dt=((performance.now()-t0)|0);
      const faces = res?.faceLandmarks || [];
      log(`Face: ${faces.length} in ${dt}ms`, faces.length?'good':'warn');
      const ctx = cvFace.getContext('2d'); ctx.lineWidth = 1.2; ctx.globalAlpha = 0.98;
      faces.forEach(lms=>{
        drawFace.drawConnectors(lms, window.vision.FaceLandmarker.FACE_LANDMARKS_TESSELATION, {color:'#2bd1ff2a'});
        drawFace.drawConnectors(lms, window.vision.FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, {color:'#00e0ff'});
        drawFace.drawConnectors(lms, window.vision.FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, {color:'#ff5572'});
        drawFace.drawConnectors(lms, window.vision.FaceLandmarker.FACE_LANDMARKS_LEFT_EYE,  {color:'#57ff6a'});
        drawFace.drawConnectors(lms, window.vision.FaceLandmarker.FACE_LANDMARKS_LIPS,      {color:'#ffd166'});

        // Eye tilt label (outer corners approx indices 33 & 263)
        const L=lms, le=L[33], re=L[263];
        if(le && re){
          const tilt=(Math.atan2((re.y-le.y),(re.x-le.x))*180/Math.PI).toFixed(1);
          const x=((le.x+re.x)/2)*cvFace.width/window.devicePixelRatio;
          const y=((le.y+re.y)/2)*cvFace.height/window.devicePixelRatio - 12;
          ctx.save(); ctx.font='bold 12px ui-monospace'; ctx.lineWidth=3;
          ctx.strokeStyle='#061019'; ctx.fillStyle='#e6f6ff';
          ctx.strokeText(`eye tilt ${tilt}°`, x, y); ctx.fillText(`eye tilt ${tilt}°`, x, y);
          ctx.restore();
        }
      });
    }

    // POSE
    if (wantPose){
      const t0=performance.now();
      const res = poseLM.detect(src);
      const dt=((performance.now()-t0)|0);
      const poses = res?.landmarks || [];
      log(`Pose: ${poses.length} in ${dt}ms`, poses.length?'good':'warn');
      if (poses[0]){
        drawPose.drawLandmarks(poses[0], {radius:2, color:'#aaf'});
        drawPose.drawConnectors(poses[0], window.vision.PoseLandmarker.POSE_CONNECTIONS, {color:'#89f'});
        // label a few joints
        const p=poses[0], ctx=cvPose.getContext('2d');
        const S=i=>p[i] && [ p[i].x*cvPose.width/window.devicePixelRatio, p[i].y*cvPose.height/window.devicePixelRatio ];
        const lbl={LShoulder:S(11),RShoulder:S(12),LHip:S(23),RHip:S(24),LKnee:S(25),RKnee:S(26)};
        ctx.save(); ctx.font='bold 12px ui-monospace'; ctx.lineWidth=3; ctx.strokeStyle='#081019'; ctx.fillStyle='#e6f6ff';
        for (const [k,v] of Object.entries(lbl)) if(v){ ctx.strokeText(k, v[0], v[1]); ctx.fillText(k, v[0], v[1]); }
        ctx.restore();
      }
    }

    // SEGMENTATION
    if (wantSegm){
      const t0=performance.now();
      const res = segm.segment(src);
      const dt=((performance.now()-t0)|0);
      const mask = res?.categoryMask;
      log(`Seg: ${mask?'mask ok':'none'} in ${dt}ms`, mask?'good':'warn');
      if (mask){
        const ctx=cvSeg.getContext('2d');
        const w = src.width, h = src.height;
        const imgData = ctx.createImageData(w,h);
        // classes: 0 bg, 1 hair, 2 face, 3 skin, 4 clothes, 5 accessories
        const COLORS = {
          0:[0,0,0,0], 1:[100,240,255,120], 2:[255,210,80,140],
          3:[255,120,120,80], 4:[120,180,255,90], 5:[190,120,255,90]
        };
        for(let i=0;i<mask.width*mask.height;i++){
          const lab = mask.data[i]||0;
          const [r,g,b,a] = COLORS[lab]||[0,0,0,0];
          const j=i*4; imgData.data[j]=r; imgData.data[j+1]=g; imgData.data[j+2]=b; imgData.data[j+3]=a;
        }
        const tmp=document.createElement('canvas'); tmp.width=w; tmp.height=h;
        tmp.getContext('2d').putImageData(imgData,0,0);
        ctx.drawImage(tmp,0,0,w,h);
      }
    }
  }

  // Load/fit image
  function loadBlob(blob){
    const url = URL.createObjectURL(blob);
    imgEl.onload = ()=>{ URL.revokeObjectURL(url); $('#imgMeta').textContent = `Loaded ${imgEl.naturalWidth}×${imgEl.naturalHeight}`; fitCanvases(); };
    imgEl.src = url;
  }

  $('#fileInput').addEventListener('change', e=>{
    const f=e.target.files?.[0]; if(!f) return; loadBlob(f);
  });
  $('#btnDemo').addEventListener('click', async ()=>{
    const res = await fetch('https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=1400&q=85');
    loadBlob(await res.blob());
  });

  $('#btnFit').addEventListener('click', fitCanvases);
  $('#btnAnalyze').addEventListener('click', analyze);
  $('#btnClear').addEventListener('click', clearOverlays);

  // Self test: check bundle + HEAD model URLs + init tasks once
  $('#btnSelfTest').addEventListener('click', async ()=>{
    try{
      log('--- Self-Test start ---','mut');
      if (!window.vision){ log('vision_bundle.js not present', 'bad'); return; }
      async function head(u){ try{ const r=await fetch(u,{method:'HEAD'}); return r.ok; }catch(e){ return false; } }
      const h1 = await head(MODEL.face), h2 = await head(MODEL.pose), h3 = await head(MODEL.segm);
      log(`HEAD face:${h1?'OK':'X'} pose:${h2?'OK':'X'} seg:${h3?'OK':'X'}`, (h1&&h2&&h3)?'good':'warn');
      const ok = await ensureTasks(); if(!ok) return;
      log('All tasks constructed ✔︎','good');
      log('--- Self-Test done ---','mut');
    }catch(e){ console.error(e); log('Self-Test error: '+e.message, 'bad'); }
  });

  // Fit on resize
  addEventListener('resize', ()=>{ if(imgEl.naturalWidth) fitCanvases(); }, {passive:true});
})();
</script>
</body>
</html>
