<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PF — ImageIntel (Stable Preview + Analysis)</title>
<meta name="robots" content="noindex,nofollow"/>
<meta name="description" content="Stable image intel lab: persistent base image, resilient preview overlay, and analysis with optional HuggingFace."/>
<style>
:root{
  --bg:#0b0f14; --ink:#d6f5ff; --edge:#232a33; --aqua:#64f2e3; --ok:#55d69a; --bad:#ff6b6b; --warn:#ffd166; --dim:#9db1bd;
}
*{box-sizing:border-box}
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:ui-monospace,Menlo,Consolas,monospace}
.wrap{max-width:1180px;margin:0 auto;padding:16px}
h1{margin:0 0 10px;font-size:1.1rem}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
.badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--edge);padding:6px 10px;border-radius:999px;background:#0b1117dd}
.ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)} .note{color:var(--dim)}
.btn{cursor:pointer;border:1.5px solid var(--aqua);background:#131922;color:#b8fff6;padding:8px 12px;border-radius:10px;font-weight:700}
.btn:hover{background:var(--aqua);color:#0e131a;border-color:#fff}
.btn:disabled{opacity:.5;cursor:not-allowed}

.stepper{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:12px 0}
.step{border:1px solid var(--edge);border-radius:10px;padding:10px;background:#0f161f}
.step.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}

.stage{position:relative;border:1px solid var(--edge);border-radius:12px;background:#0d131a;overflow:hidden}
.inner{position:relative;aspect-ratio:16/9}
#baseImg{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;object-position:center center;display:block;user-select:none;pointer-events:none}
#over{position:absolute;inset:0;width:100%;height:100%;display:block;pointer-events:none}

.legend{position:absolute;left:12px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:3}
.scanGlow{position:absolute;left:0;top:0;height:2px;background:linear-gradient(90deg, transparent, #64f2e3, transparent);box-shadow:0 0 12px #64f2e3aa;opacity:0;pointer-events:none;transition:opacity .12s ease}

.tab-head{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
.tab-head button{cursor:pointer;border:1px solid var(--edge);background:#0e141a;color:var(--ink);padding:8px 12px;border-radius:9px}
.tab-head button.active{border-color:var(--aqua);box-shadow:0 0 0 2px #64f2e333 inset}
.tab{display:none;margin-top:10px;border:1px solid var(--edge);border-radius:12px;padding:12px;background:#0e141a}
.tab.active{display:block}
textarea.out{width:100%;min-height:120px;background:#0b1117;color:#d8faff;border:1px solid #1b242e;border-radius:8px;padding:10px}

.toastbox{position:fixed;right:14px;bottom:14px;display:flex;flex-direction:column;gap:10px;z-index:5000}
.toast{background:#121823ee;border:1px solid var(--edge);color:#defaff;padding:10px 12px;border-radius:10px;min-width:220px;box-shadow:0 4px 18px #0006}

.diag{margin-top:12px;border:1px dashed var(--edge);padding:10px;border-radius:10px;background:#0c1117}
.kv{display:grid;grid-template-columns:160px 1fr;gap:6px 12px}
code.err{display:block;white-space:pre-wrap;background:#0b1117;border:1px solid #1b242e;border-radius:8px;padding:8px;margin-top:6px;color:#ffb4b4}
</style>
</head>
<body>
<div class="wrap">
  <h1>ImageIntel — Stable Preview + Analysis</h1>

  <!-- Status -->
  <div class="row">
    <span class="badge">Init: <b id="initState">booting…</b></span>
    <span class="badge">Bundle: <b id="bundleState">…</b></span>
    <span class="badge">Model: <b id="modelState">…</b></span>
    <span class="badge">Ready: <b id="readyState">no</b></span>
  </div>

  <!-- Stage -->
  <div class="stage">
    <div class="inner" id="stage">
      <img id="baseImg" alt=""/>
      <canvas id="over"></canvas>
      <div id="scanLine" class="scanGlow"></div>
      <div class="legend">
        <span class="badge">faces: <span id="faceCount">0</span></span>
        <span class="badge">active face: <span id="activeFaceIdx">—</span></span>
      </div>
    </div>
  </div>

  <!-- Wizard -->
  <div class="stepper">
    <div class="step active" id="s1">
      <h3>Step 1 — Load</h3>
      <div class="row">
        <input id="file" type="file" accept="image/*"/>
        <button class="btn" id="demo">Load Demo</button>
        <button class="btn" id="next1" disabled>Next</button>
      </div>
      <div class="note">Pick any image. It appears instantly and stays during scroll/resize.</div>
    </div>

    <div class="step" id="s2">
      <h3>Step 2 — Options</h3>
      <div class="row">
        <label><input type="checkbox" id="scanFace" checked> Face</label>
        <label><input type="checkbox" id="scanBody"> Body</label>
        <label><input type="checkbox" id="scanNSFW"> NSFW</label>
        <label><input type="checkbox" id="scanObjects"> Objects</label>
      </div>
      <div class="row">
        <label>Detail <input id="detail" type="range" min="1" max="3" step="1" value="2"></label>
        <label>Spice <input id="spice" type="range" min="0" max="3" step="1" value="1"></label>
      </div>
      <div class="row">
        <button class="btn" id="preview" disabled>Preview Overlay</button>
        <button class="btn" id="next2" disabled>Next</button>
      </div>
    </div>

    <div class="step" id="s3">
      <h3>Step 3 — Cloud (optional)</h3>
      <div class="row">
        <label><input type="checkbox" id="useCloud"> HuggingFace</label>
        <input id="hfToken" placeholder="hf_... token" style="min-width:320px;border:1px solid var(--edge);background:#0f141a;color:#fff;padding:6px 10px;border-radius:8px">
        <button class="btn" id="run" disabled>Run Analysis</button>
      </div>
      <div class="note">BLIP caption / CLIP Interrogator / DETR objects (optional).</div>
    </div>

    <div class="step" id="s4">
      <h3>Step 4 — Results</h3>
      <div class="row" id="faceSelector"></div>
      <div class="row">
        <button class="btn" id="copySFW" disabled>Copy SFW</button>
        <button class="btn" id="copyNSFW" disabled>Copy NSFW</button>
        <button class="btn" id="exportJSON" disabled>Export JSON</button>
        <button class="btn" id="rerun">Re-Run</button>
      </div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tab-head">
    <button class="active" data-tab="sfw">SFW Prompt</button>
    <button data-tab="nsfw">NSFW Prompt</button>
    <button data-tab="meas">Measurements</button>
    <button data-tab="json">JSON</button>
    <button data-tab="diag">Diagnostics</button>
  </div>
  <div id="tab_sfw" class="tab active"><textarea id="outSFW" class="out" readonly></textarea></div>
  <div id="tab_nsfw" class="tab"><textarea id="outNSFW" class="out" readonly></textarea></div>
  <div id="tab_meas" class="tab"><textarea id="outMeas" class="out" readonly></textarea></div>
  <div id="tab_json" class="tab"><textarea id="outJson" class="out" readonly></textarea></div>
  <div id="tab_diag" class="tab">
    <div class="diag">
      <div class="kv">
        <div>UA:</div><div id="ua"></div>
        <div>Natural size:</div><div id="naturalSz">—</div>
        <div>Rendered box:</div><div id="renderedSz">—</div>
        <div>Canvas:</div><div id="canvasSz">—</div>
        <div>Last event:</div><div id="last">ready</div>
        <div>Errors:</div><div id="errors"><small class="note">none</small></div>
      </div>
    </div>
  </div>
</div>

<div class="toastbox" id="toastbox"></div>

<script type="module">
/* =================== helpers & diagnostics =================== */
const $=id=>document.getElementById(id);
const toastbox=$('toastbox');
const toast=(m)=>{const d=document.createElement('div');d.className='toast';d.textContent=m;toastbox.appendChild(d);setTimeout(()=>d.remove(),2400);};
$('ua').textContent=navigator.userAgent;
const setLast=t=>$('last').textContent=String(t);
const pushErr=(e)=>{const p=$('errors'); const c=document.createElement('code'); c.className='err'; c.textContent=String(e?.stack||e); p.appendChild(c);};

/* =================== layers & sizing (IMG + overlay) =================== */
const stage=$('stage'), baseImg=$('baseImg'), over=$('over'), octx=over.getContext('2d');
let imgReady=false, imgNatural={w:0,h:0}, imgBox={x:0,y:0,w:0,h:0};

function updateBoxes(){
  const s=stage.getBoundingClientRect();
  const i=baseImg.getBoundingClientRect();
  over.width=Math.max(1,Math.round(s.width));
  over.height=Math.max(1,Math.round(s.height));
  over.style.width=s.width+'px'; over.style.height=s.height+'px';
  imgBox={ x:Math.round(i.left - s.left), y:Math.round(i.top - s.top), w:Math.round(i.width), h:Math.round(i.height) };
  $('renderedSz').textContent=`${imgBox.w}×${imgBox.h} @ (${imgBox.x},${imgBox.y})`;
  $('canvasSz').textContent=`${over.width}×${over.height}`;
}
new ResizeObserver(updateBoxes).observe(stage);
addEventListener('resize', updateBoxes, {passive:true});
addEventListener('scroll', updateBoxes, {passive:true});

/* =================== image loading =================== */
function enableStep2Buttons(){ $('preview').disabled=false; $('next2').disabled=false; $('run').disabled=false; }
function enableNext1(){ $('next1').disabled=false; $('readyState').textContent='yes'; }

function loadFromFile(file){
  if(!file){ toast('No file'); return; }
  const reader=new FileReader();
  reader.onload=()=>{
    baseImg.onload=()=>{
      imgReady=true; imgNatural={w:baseImg.naturalWidth,h:baseImg.naturalHeight};
      $('naturalSz').textContent=`${imgNatural.w}×${imgNatural.h}`;
      updateBoxes(); enableNext1(); enableStep2Buttons();
      toast('Image loaded.'); setLast('image onload');
    };
    baseImg.onerror=(e)=>{ imgReady=false; pushErr(e); toast('Image decode error'); };
    baseImg.src=reader.result; baseImg.alt=file.name||'image';
  };
  reader.onerror=(e)=>{ pushErr(e); toast('File read error'); };
  reader.readAsDataURL(file);
}

$('file').addEventListener('change', e=>{ const f=e.target.files?.[0]; loadFromFile(f); });
const demoPng="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANAAAADQCAYAAAD3QmL4AAAACXBIWXMAAAsSAAALEgHS3X78AAABc0lEQVR4nO3TwQmDQBQF0eT9T2iZgQq3Zy7y1qkH1bYw+5h4v5yKp1lGgAAAAAAAAAAAAAAAPzXr8nqGk9i2y3bG2wqk9gRz8yVwz5w7k1m0t0b3m4v0bq9wq3g5w4e3Qv6wz7P3vTgPpJkAAJ4w0n8C3q7v9v0FJr7nYt9b3x2cW3O2mXxg7iB9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ9cT9cQ+eGgAA+S9cFf7r+f3bJrS6cV7fNw9u8s7xw7v+f2C6v7p/8eZ7c4+f3b8v7n+DDkAAE9h8gMAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAgAAfIYCAAB8hgIAAHyGAoB1B/0iJ7o9J0c9AAAAAElFTkSuQmCC";
$('demo').addEventListener('click', ()=>{ baseImg.onload=()=>{ imgReady=true; imgNatural={w:baseImg.naturalWidth,h:baseImg.naturalHeight}; $('naturalSz').textContent=`${imgNatural.w}×${imgNatural.h}`; updateBoxes(); enableNext1(); enableStep2Buttons(); toast('Demo image loaded.'); }; baseImg.src=demoPng; baseImg.alt='demo'; });

function setStep(n){
  ['s1','s2','s3','s4'].forEach((id,i)=>$(id).classList.toggle('active',(i+1)===n));
  updateBoxes();
}
setStep(1);
$('next1').addEventListener('click', ()=>setStep(2));
$('next2').addEventListener('click', ()=>setStep(3));
$('rerun').addEventListener('click', ()=>setStep(2));

/* =================== MediaPipe models (gated readiness) =================== */
$('initState').textContent='loading bundle…';
let FaceLandmarker, PoseLandmarker, DrawingUtils, FilesetResolver;
let face=null, pose=null, modelsReady=false;

(async ()=>{
  try{
    const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs");
    ({FilesetResolver, FaceLandmarker, PoseLandmarker, DrawingUtils} = vision);
    $('bundleState').innerHTML='<span class="ok">OK</span>';
    $('initState').textContent='loading models…';
    const fs = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
    face = await FaceLandmarker.createFromOptions(fs,{baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"},runningMode:'IMAGE',numFaces:5});
    pose = await PoseLandmarker.createFromOptions(fs,{baseOptions:{modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task"},runningMode:'IMAGE'});
    modelsReady=true;
    $('modelState').innerHTML='<span class="ok">OK</span>';
    $('initState').textContent='ready';
    // If image already loaded, allow preview/run
    if(imgReady) enableStep2Buttons();
  }catch(e){
    pushErr(e);
    $('bundleState').innerHTML='<span class="bad">FAIL</span>';
    $('modelState').innerHTML='<span class="bad">FAIL</span>';
    $('initState').textContent='init error';
  }
})();

/* =================== overlay & math =================== */
const faceCountEl=$('faceCount'), activeFaceIdxEl=$('activeFaceIdx'), faceSelector=$('faceSelector');
const outSFW=$('outSFW'), outNSFW=$('outNSFW'), outMeas=$('outMeas'), outJson=$('outJson');
const copySFW=$('copySFW'), copyNSFW=$('copyNSFW'), exportJSON=$('exportJSON');
const scanFace=$('scanFace'), scanBody=$('scanBody'), scanNSFW=$('scanNSFW'), scanObjects=$('scanObjects');
const detail=$('detail'), spice=$('spice');
const useCloud=$('useCloud'), hfToken=$('hfToken');

let analysis=null, activeFace=0;

function mapNormToBox(p){ return { x: imgBox.x + p.x*imgBox.w, y: imgBox.y + p.y*imgBox.h, z: p.z ?? 0 }; }
const dist=(a,b,lm)=>Math.hypot(lm[a].x-lm[b].x, lm[a].y-lm[b].y);
const eyeAngleDeg=(lm)=>+(Math.atan2(lm[362].y-lm[133].y, lm[362].x-lm[133].x)*180/Math.PI).toFixed(2);
function bbox(lm){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of lm){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function classify(jaw_face,cheek_face){ if(jaw_face<0.45 && cheek_face<0.55) return 'oval'; if(Math.abs(jaw_face-cheek_face)<0.03 && jaw_face>0.5) return 'round'; if(jaw_face>=0.55 && cheek_face>=0.6) return 'square'; if(cheek_face>jaw_face+0.07) return 'heart'; return 'triangle'; }

/* Animated scanner */
let rafId=null, sweepY=0, scanning=false;
function startScan(){
  const scanLine=$('scanLine');
  scanning=true; sweepY=imgBox.y; scanLine.style.opacity='1';
  const tick=()=>{
    if(!scanning) return;
    scanLine.style.top=sweepY+'px'; scanLine.style.left=imgBox.x+'px'; scanLine.style.width=imgBox.w+'px';
    drawOverlay(sweepY); sweepY+=Math.max(2,imgBox.h/40);
    if(sweepY>imgBox.y+imgBox.h){ drawOverlay(null,true); stopScan(); return; }
    rafId=requestAnimationFrame(tick);
  };
  rafId=requestAnimationFrame(tick);
}
function stopScan(){ scanning=false; cancelAnimationFrame(rafId); $('scanLine').style.opacity='0'; }

/* Draw overlay with optional reveal clip */
function drawOverlay(clipY=null, full=false){
  octx.clearRect(0,0,over.width,over.height);
  if(!analysis?.faces?.length) return;
  if(clipY!==null && !full){
    octx.save(); octx.beginPath(); octx.rect(imgBox.x,imgBox.y,imgBox.w,Math.max(0,Math.min(imgBox.h,clipY-imgBox.y))); octx.clip();
  }
  const d=new DrawingUtils(octx);
  analysis.faces.forEach((f,idx)=>{
    const col = idx===activeFace ? 'rgba(100,242,227,.95)' : 'rgba(100,242,227,.35)';
    try{ d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_TESSELLATION, {color:col,lineWidth:.9}); }catch{}
    d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_LIPS, {color:'rgba(255,120,160,.9)',lineWidth:2});
    d.drawConnectors(f.landmarks_canvas, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, {color:'rgba(140,255,220,.9)',lineWidth:2});
  });
  if(clipY!==null && !full) octx.restore();
}

/* Build outputs */
function buildOutputs(){
  const f=analysis?.faces?.[activeFace];
  if(!f){ outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=JSON.stringify(analysis||{},null,2); return; }
  outSFW.value=`portrait, ${f.shape} face, jaw/face ${f.ratios.jaw_face}, cheek/face ${f.ratios.cheek_face}, eye angle ${f.measures.eye_angle_deg}°`;
  outNSFW.value= scanNSFW.checked ? (f.nsfw?.breast_size ? `${f.nsfw.breast_size} breasts, ${f.nsfw.nipples_visible?'visible nipples':'covered'}` : 'nsfw heuristics: none') : '';
  outMeas.value=`H ${f.measures.face_height}px, jaw ${f.measures.jaw_width}px, cheek ${f.measures.cheek_width}px`;
  outJson.value=JSON.stringify(analysis,null,2);
  copySFW.disabled=false; exportJSON.disabled=false; copyNSFW.disabled=!scanNSFW.checked;
}
function mkFacePills(){
  faceSelector.innerHTML='';
  (analysis.faces||[]).forEach((f,idx)=>{
    const b=document.createElement('button'); b.className='btn'; b.textContent='Face '+idx;
    b.addEventListener('click',()=>{ activeFace=idx; activeFaceIdxEl.textContent=idx; drawOverlay(null,true); buildOutputs(); });
    faceSelector.appendChild(b);
  });
}

/* =================== PREVIEW (Step 2) — now fully gated =================== */
$('preview').addEventListener('click', async ()=>{
  try{
    if(!imgReady){ toast('Load an image first.'); return; }
    if(!modelsReady || !face){ toast('Models still loading.'); return; }
    if(!scanFace.checked){ toast('Enable Face option.'); return; }
    setLast('preview start');

    // detect from the IMG element (robust)
    const res = await face.detect(baseImg);
    const lms = res?.faceLandmarks || [];
    faceCountEl.textContent = lms.length;
    if(!lms.length){ analysis=null; octx.clearRect(0,0,over.width,over.height); outSFW.value=''; outNSFW.value=''; outMeas.value=''; outJson.value=''; toast('No faces found'); return; }

    // snapshot of rendered image box (for sampling colors / later NSFW)
    const snap=document.createElement('canvas'); snap.width=imgBox.w; snap.height=imgBox.h;
    const sctx=snap.getContext('2d',{willReadFrequently:true}); sctx.drawImage(baseImg,0,0,imgBox.w,imgBox.h);
    const snapData=sctx.getImageData(0,0,imgBox.w,imgBox.h);

    function avgRectHex_local(x,y,w,h,step=2){ const d=snapData.data,W=snap.width,H=snap.height; const x0=Math.max(0,Math.floor(x)),y0=Math.max(0,Math.floor(y)),x1=Math.min(W,Math.floor(x+w)),y1=Math.min(H,Math.floor(y+h)); let R=0,G=0,B=0,c=0; for(let yy=y0;yy<y1;yy+=step){ for(let xx=x0;xx<x1;xx+=step){ const i=(yy*W+xx)*4; R+=d[i]; G+=d[i+1]; B+=d[i+2]; c++; }} if(!c) return '#000000'; R=(R/c)|0; G=(G/c)|0; B=(B/c)|0; return '#'+[R,G,B].map(v=>v.toString(16).padStart(2,'0')).join(''); }

    const facesOut=[];
    for(let fi=0; fi<lms.length; fi++){
      const lmN=lms[fi];
      const lmC=lmN.map(p=>mapNormToBox(p));
      const faceH=dist(10,152,lmC), jawW=dist(234,454,lmC), cheekW=dist(234,454,lmC);
      const ratios={jaw_face:+(jawW/faceH).toFixed(3), cheek_face:+(cheekW/faceH).toFixed(3)};
      const eyeDeg=eyeAngleDeg(lmC);
      const shape=classify(ratios.jaw_face, ratios.cheek_face);
      const bb=bbox(lmC); const fW=bb.maxX-bb.minX, fH=bb.maxY-bb.minY;
      const hair=avgRectHex_local(bb.minX-imgBox.x, Math.max(0,bb.minY-imgBox.y-12), fW, 10, 1);
      const skin=avgRectHex_local((bb.minX-imgBox.x)+0.35*fW, (bb.minY-imgBox.y)+0.45*fH, 18,18, 1);
      const e=lmC[133]; const eyes=avgRectHex_local((e.x-imgBox.x)-8,(e.y-imgBox.y)-8,16,16,1);

      // crude NSFW chest window (within image box)
      let nsfw=null;
      if(scanNSFW.checked){
        const cx=(bb.minX+bb.maxX)/2;
        let rect={x:cx-0.68*fW, y:bb.maxY+0.12*fH, w:1.36*fW, h:1.10*fH};
        rect.x=Math.max(imgBox.x,rect.x); rect.y=Math.max(imgBox.y,rect.y);
        rect.w=Math.min(rect.w,(imgBox.x+imgBox.w)-rect.x); rect.h=Math.min(rect.h,(imgBox.y+imgBox.h)-rect.y);
        // skin ratio inside rect
        const sx=Math.max(0,Math.floor(rect.x-imgBox.x)), sy=Math.max(0,Math.floor(rect.y-imgBox.y)), sw=Math.floor(rect.w), sh=Math.floor(rect.h);
        let skinCnt=0, tot=0; const d=snapData.data, W=snap.width;
        for(let yy=sy;yy<sy+sh;yy+=2){ for(let xx=sx;xx<sx+sw;xx+=2){ const i=(yy*W+xx)*4; const r=d[i],g=d[i+1],b=d[i+2]; const y=0.299*r+0.587*g+0.114*b, cb=-0.168736*r-0.331264*g+0.5*b+128, cr=0.5*r-0.418688*g-0.081312*b+128; if(cb>77&&cb<127&&cr>133&&cr<173&&y>40) skinCnt++; tot++; }}
        const skinRatio=tot?skinCnt/tot:0; const chestRatio=rect.w/faceH; let breast='unknown';
        if(skinRatio>0.55){ if(chestRatio<1.55) breast='small'; else if(chestRatio<2.05) breast='medium'; else breast='large'; }
        nsfw={chest_rect:rect, chest_skin_ratio:+skinRatio.toFixed(3), breast_size:breast, nipples_visible:(skinRatio>0.55)};
      }

      facesOut.push({
        index:fi,
        measures:{face_height:+faceH.toFixed(2), jaw_width:+jawW.toFixed(2), cheek_width:+cheekW.toFixed(2), eye_angle_deg:eyeDeg},
        ratios, shape, palette:{hair,skin,eyes}, landmarks_canvas:lmC, nsfw
      });
    }

    analysis={version:'pf_facemapper_3_plus', frame:{type:'image'}, image:{natural:imgNatural, box:imgBox}, faces:facesOut, pose:null, scene:{bgTag:'heuristic'}, cloud:null};
    faceCountEl.textContent=facesOut.length; activeFace=0; activeFaceIdxEl.textContent=facesOut.length?0:'—';
    mkFacePills(); buildOutputs();

    // animate & settle
    startScan(); setTimeout(()=>drawOverlay(null,true), 1500); setTimeout(()=>stopScan(), 1500);
    setLast('preview done');
  }catch(e){ pushErr(e); toast('Preview error (see Diagnostics)'); }
});

/* =================== RUN (Step 3→4) — never a no-op =================== */
$('run').addEventListener('click', async ()=>{
  try{
    if(!imgReady){ toast('Load an image first.'); return; }
    if(!modelsReady){ toast('Models still loading.'); return; }
    // Ensure we have at least preview analysis:
    if(!analysis){ await new Promise(r=>{ const handler=()=>{ $('preview').removeEventListener('click',handler); r(); }; $('preview').click(); setTimeout(handler, 10); }); }
    setStep(4);
    // Optional Cloud (kept simple; never blocks local results)
    if(useCloud.checked && hfToken.value.trim()){
      const blob=await new Promise(r=>{ try{ // draw the visible box to temp canvas
        const c=document.createElement('canvas'); c.width=imgBox.w; c.height=imgBox.h; c.getContext('2d').drawImage(baseImg,0,0,imgBox.w,imgBox.h); c.toBlob(r,'image/png',0.92);
      }catch(e){ r(null); }});
      const post=async(model)=>{ const r=await fetch(`https://api-inference.huggingface.co/models/${model}`,{method:'POST',headers:{'Authorization':`Bearer ${hfToken.value.trim()}`},body:blob}); if(!r.ok) throw new Error(model+': '+r.status); return r.json(); };
      try{
        const cap = await post('Salesforce/blip-image-captioning-large').catch(()=>null);
        const clip= await post('pharma/CLIP-Interrogator').catch(()=>null);
        analysis.cloud={ caption: cap?.[0]?.generated_text||null, clip_prompt: clip?.[0]?.generated_text||clip?.generated_text||null };
        outJson.value=JSON.stringify(analysis,null,2);
      }catch(e){ pushErr(e); }
    }
    buildOutputs();
    drawOverlay(null,true);
    setLast('run done');
  }catch(e){ pushErr(e); toast('Run error (see Diagnostics)'); }
});

/* =================== tabs & copy/export =================== */
document.querySelectorAll('.tab-head button').forEach(b=>{
  b.addEventListener('click',()=>{
    document.querySelectorAll('.tab-head button').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    const t=$('tab_'+b.dataset.tab); if(t) t.classList.add('active');
  });
});
copySFW.addEventListener('click',()=>navigator.clipboard.writeText(outSFW.value||'').then(()=>toast('Copied SFW')));
copyNSFW.addEventListener('click',()=>navigator.clipboard.writeText(outNSFW.value||'').then(()=>toast('Copied NSFW')));
exportJSON.addEventListener('click',()=>{
  const blob=new Blob([outJson.value||'{}'],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='imageintel.json'; document.body.appendChild(a); a.click();
  setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);},150);
});

/* =================== small UX: enable Preview/Next when both ready =================== */
const maybeEnable=()=>{ if(imgReady && modelsReady){ $('preview').disabled=false; $('next2').disabled=false; $('run').disabled=false; }};
const obs=new MutationObserver(maybeEnable); obs.observe($('readyState'),{childList:true}); // not critical but keeps it tidy
</script>
</body>
</html>
